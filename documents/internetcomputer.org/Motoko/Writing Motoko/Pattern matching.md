---
sidebar_position: 19
---

# パターンマッチング

パターンマッチングは、構造化されたデータを簡単にテストし、構成要素に分解して指定した名前にバインディングすることで、それらのフラグメントをスコープに持ち込むための言語機能です。ほとんどのプログラミング言語では、構造化データを構築する方法が提供されていますが、パターンマッチングは構造化データを分解し、その構成要素を指定した名前にバインディングすることを可能にします。構文的には、パターンは構造化データの構築に似ていますが、一般的には関数の引数の位置や、`switch`式での`case`キーワードの後、`let`や`var`宣言の後など、入力方向の位置に現れます。

## パターンの種類

以下の表は、異なるパターンマッチングの方法をまとめたものです。

| パターンの種類                | 例                             | コンテキスト     | 失敗する可能性               | 備考                                  |
|------------------------------|---------------------------------|------------------|----------------------------|---------------------------------------|
| リテラル                      | `null`, `42`, `()`, `"Hi"`      | どこでも          | 型に複数の値がある場合      |                                       |
| 名前付き                      | `age`, `x`                      | どこでも          | なし                        | 新しいスコープに識別子を導入         |
| ワイルドカード                | `_`                             | どこでも          | なし                        |                                       |
| 型付き                        | `age : Nat`                     | どこでも          | 条件付き                    |                                       |
| オプション                    | `?0`, `?val`                    | どこでも          | はい                        | [オプションブロック](#option-blocks-for-streamlined-processing-of-optional-data)も参照 |
| タプル                         | `( component0, component1, …​ )` | どこでも          | 条件付き                    | 少なくとも2つのコンポーネントが必要  |
| オブジェクト                   | `{ fieldA; fieldB; …​ }`         | どこでも          | 条件付き                    | フィールドのサブセットを指定することができる |
| フィールド                     | `age`, `count = 0`              | オブジェクト      | 条件付き                    | `age` は `age = age` の省略形         |
| バリアント                     | `#celsius deg`, `#sunday`       | どこでも          | はい                        | `#sunday` は `#sunday ()` の省略形    |
| 論理和（`or`パターン）         | `0 or 1`                        | どこでも          | 状況による                  | 代替パターンは識別子をバインドしない  |

## パターンマッチングの使用

次の関数呼び出しを考えてみましょう：

```ts no-repl
let name : Text = fullName({ first = "Jane"; mid = "M"; last = "Doe" });
```

このコードは、3つのフィールドを持つレコードを構築し、それを関数 `fullName` に渡します。呼び出しの結果は名前を付けられ、識別子 `name` にバインディングされてスコープに取り込まれます。最後のバインディングのステップがパターンマッチングと呼ばれ、`name : Text` は最も簡単なパターンの1つです。例えば、以下の呼び出し元の実装では：

```ts
func fullName({ first : Text; mid : Text; last : Text }) : Text {
  first # " " # mid # " " # last
};
```

入力は匿名オブジェクトで、3つの [`Text`](../base/Text.md) フィールドに分解され、その値が識別子 `first`、`mid`、`last` にバインディングされます。これらは関数の本体を構成するブロック内で自由に使用できます。上記では名前の冗長表現を利用して、オブジェクトフィールドのパターンをエイリアスとして使用しています。フィールドパターンのより一般的な形式では、内容をフィールドとは別に名前付けすることができます（例：`…​; mid = m : Text; …​`）。ここで `mid` はマッチするフィールドを決定し、`m` はそのフィールドの内容をパターンのスコープ内で名前付けします。

## リテラルパターン

パターンマッチングを使用してリテラルパターンを宣言することもできます。リテラルパターンはリテラル定数と非常に似ています。リテラルパターンは特に `switch` 式で役立ちます。なぜなら、現在のパターンマッチが失敗し、次のパターンをマッチさせることができるからです。例えば：

```ts
switch ("Adrienne", #female) {
  case (name, #female) { name # " is a girl!" };
  case (name, #male) { name # " is a boy!" };
  case (name, _) { name # ", is a human!" };
}
```

このプログラムは最初の `case` 節にマッチします。なぜなら、識別子 `name` へのバインディングは失敗しないため、ショートハンドのバリアントリテラル `#female` が等しいと比較されるからです。その後、`"Adrienne is a girl!"` が評価されます。最後の節ではワイルドカードパターン `_` を示しています。これは失敗することはありませんが、識別子にはバインドされません。

## `or` パターン

最後のパターンは `or` パターンです。その名の通り、これらは `or` キーワードで区切られた2つ以上のパターンです。各サブパターンは同じ識別子セットにバインディングし、左から右にマッチします。`or` パターンは、最右のサブパターンが失敗した場合に失敗します。

## パターンについての詳細

パターンマッチングは豊かな歴史と興味深い仕組みを持っているため、いくつかの追加コメントが正当化されます。

### 用語

値がマッチされる式は、頻繁に**スクルティニ（調査対象）**と呼ばれます。`case` キーワードの後に現れるパターンは**代替案**です。スクルティニのすべての可能な値が少なくとも1つの代替案によってマッチされると、スクルティニは**カバーされる**と呼ばれます。代替案は順番に試されます。重複するパターンがある場合、先に出現したものが選択されます。代替案は、すべての値に対してすでに他の代替案が一致する場合に死んでいる、または冗長であると見なされます。

### ブール値

データ型 [`Bool`](../base/Bool.md) は2つの離散した代替（`true` と `false`）として扱うことができ、Motoko の組み込み `if` 構文はそのデータを排除し、制御フローに変換します。`if` 式はパターンマッチングの一形態であり、ブール型のスクルティニに関する特別なケースとして一般的な `switch` 式を省略したものです。

### バリアントパターン

Motoko のバリアント型は離散的な和集合の一形態であり、時には和型（sum type）とも呼ばれます。バリアント型の値は常に1つの識別子（ディスクリミネータ）と、そのディスクリミネータに応じて変動するペイロードを持ちます。バリアントパターンをバリアント値でマッチングするとき、ディスクリミネータが一致する必要があり、その場合、ペイロードはさらにマッチングされます。

### 列挙型

他のプログラミング言語では、`enum` キーワードを使って離散的な列挙を定義することが一般的です。これらは Motoko のより一般的なバリアント型の親戚であり、列挙の代替案はペイロードを持つことができません。対応して、これらの言語で使用される `switch` のような式は、パターンマッチングの完全な力を持っていません。Motoko は、`type Weekday = { #mon; #tue; …​ }` のように、ペイロードを必要としない基本的な列挙型を定義するためのショートハンド構文を提供します。

### エラーハンドリング

エラーハンドリングは、パターンマッチングの使用ケースと考えることができます。関数が成功と失敗の2つの代替を持つ値を返す場合、パターンマッチングを使用してそれらを区別できます。[エラーハンドリング](errors.md)を参照してください。

### 不可反復パターン

パターンが反復可能である場合、そのパターンに対して期待される型の値と一致させることが失敗する可能性があります。リテラルパターンやバリアントパターンは通常反復可能です。なぜなら、値やバリアントタグが一致する必要があり、これが一致しない可能性があるからです。

一方、すべての値に対して一致しないことがないパターンは不可反復パターンです。不可反復パターンの例としては、ワイルドカードパターン `_`、識別子パターン `x`、および不可反復のサブパターンから構築されたタプルやレコードパターンがあります。

### シングルトン型

いくつかの型には単一の値しか含まれていません。これらをシングルトン型と呼びます。例えば、ユニット型（空のタプルとしても知られる）や、シングルトン型のタプルがあります。単一のタグとペイロードがない、またはシングルトン型のペイロードを持つバリアントもシングルトン型です。シングルトン型に対するパターンマッチングは非常に簡単で、成功する一致の結果は1つだけです。

### 網羅性（カバレッジ）チェック

実行時に、`switch` 式がその代替パターンのどれにも一致しない値を調べる場合、意図しないトラップが発生する可能性があります。
このような実行時エラーを検出するために、Motoko コンパイラはスクルティニのカバレッジを追跡し、パターンマッチングの網羅性をチェックします。コンパイラはカバーされていないスクルティニについて警告を発行します。Motoko では、カバーされていないスクルティニの例を作成してくれます。網羅性チェックの有用な副産物は、決して一致しない死んだ代替案や冗長な代替案を特定して警告を出すことです。

## 反復可能なパターンと一致しないデータへの対処

Motoko の `let`-`else` 構文は、開発者が特定のパターンのデータを処理し、すべての一致しないデータを異なる制御フロー経路で処理したい場合に設計されています。標準の分解 `let` とは異なり、データが予期されたパターンと一致しない場合にトラップ（およびコンパイル時警告）するのではなく、`let`-`else` は反証された一致を処理する方法を提供します。この構文により、開発者は不一致を優雅に処理できます。

例えば、現在の関数から早期に戻る、ラベルにブレークする、またはトラップする前にメッセージをログに記録するといった方法で処理できます。

`let`-`else` は、2ケースの `switch` 文のよりコンパクトなバージョンと見ることができます。これには、後続のコードにインデントを必要としないという利点があり、可読性が向上します。この機能により、開発者はインデントしない `if`-`else` のような構造を書くことができます。

以下に、`let`-`else` を使って、インデントが増えて読みづらくなる `switch` を回避する方法を示す例を紹介します：

```ts
func getName(optionalName : ?Text) : Text {
  let ?name = optionalName else return "Unknown";
  name
}
```

`let`-`else` 構文では、`else` キーワードに続く式やブロックは `None` 型でなければなりません。これは、`let` 宣言に続くコードが実行されることなく制御フローを変更する必要があり、通常は早期に戻る、またはトラップすることを示しています。

## オプションブロックによるオプショナルデータの効率的な処理

Motoko は、オプショナルデータ（`?T` 型）をパターンマッチングで処理するための推奨方法を提供しています。これにより、他のプログラミング言語でよく見られる `null` 例外の問題を回避することができます。しかし、複数のオプションに対して複数の `switch` 文を使用するのは煩雑になり、深くネストされた読みづらいコードにつながることがあります。

これに対処するために、Motoko は *オプションブロック* という機能を導入しています。これは `do ? { ... }` の形式で書かれます。このブロックでは、後置演算子 `!` を使用してオプショナルな値を安全にアンラップできます。

ブロック内で `!` を使用することは、オプションに対する `switch` 文と同等ですが、追加の利点があります。もし `!` が `null` 値に適用されると、ブロック全体が即座に実行を中断し、`null` を返します。このショートサーキットの動作により、複数のオプショナル値を効率的かつ可読性の高い方法で処理できるようになります。

例えば、以下のようにオプションブロックを使うことができます：

```ts
do ? {
  let value = optionalValue!; // オプショナル値をアンラップ
  // 他の処理
};
```

これにより、複数のオプションに対する処理を簡潔に記述でき、冗長なネストを避けることができます。詳細については、[オプションブロックと null ブレーク](./control-flow#option-blocks-and-null-breaks)のセクションを参照してください。

このように、Motoko のパターンマッチングとオプションブロックは、データの処理を効率的に行うための強力なツールを提供し、開発者がより安全で可読性の高いコードを書くのをサポートします。
