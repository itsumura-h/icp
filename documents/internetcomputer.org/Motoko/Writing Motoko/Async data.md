---
sidebar_position: 5
---

# 非同期データ

ICPでは、カニスター間の通信は非同期です。あるカニスターから別のカニスターにメッセージとコールバックを送信することで、受信側でリクエストがスケジュールされます。リクエストの完了は、送信側にコールバックをトリガーし、結果の処理を可能にします。

Motokoでは、ICPの非同期メッセージ送信は、非同期の結果を返す共有関数を呼び出すこととして抽象化されています。Motokoは、他の多くの言語と同様に、非同期関数や計算を便利にプログラミングできるように、`async`と`await`を提供しています。

Motokoでは、非同期式を実行する際、共有関数への呼び出しであれ、単なるローカルな`async`式であれ、結果型`T`に対する`async T`型の未来（future）オブジェクトが生成されます。呼び出し元が戻り値を受け取るまで待機するのではなく、メッセージは呼び出し先にキューイングされ、その保留中のリクエストを表す未来がすぐに呼び出し元に返されます。未来は、呼び出し元が後で問い合わせることができる、リクエストの最終的な結果のプレースホルダーです。

`await`構文は未来を同期させ、未来がその生成者によって完了するまで計算を一時停止します。

リクエストを発行して結果を待つことに決めるまで、呼び出し元は他の作業を行うことができます。呼び出し先がリクエストを処理すると、未来は完了し、その結果は呼び出し元に提供されます。呼び出し元が未来を待っている場合、その実行は結果で再開されます。そうでない場合、結果は単に未来に保存され、後で使用されます。

`async`と`await`構造の組み合わせは、非同期コールバックの複雑な管理を必要とせず、`await`を通常の順次コード内に組み込むことで、非同期プログラミングを簡素化します。

## 非同期関数

非同期関数を使用した例のプログラムは次の通りです：

```ts
persistent actor Counter {

  var count = 0;

  public shared func inc() : async () { count += 1 };

  public shared func read() : async Nat { count };

  public shared func bump() : async Nat {
    count += 1;
    count;
  };
};
```

`Counter`アクターは、1つのフィールドと3つの公開された共有関数を宣言しています：

- フィールド`count`はミュータブルで、ゼロで初期化され、暗黙的に`private`です。

- 関数`inc()`は非同期でカウンターをインクリメントし、同期のために`async ()`型の未来を返します。

- 関数`read()`は非同期でカウンターの値を読み取り、`async Nat`型の未来を返します。

- 関数`bump()`は非同期でカウンターをインクリメントし、値を読み取ります。

`Counter`アクターの状態（`count`）を読み取ったり変更したりする唯一の方法は、その共有関数を通じて行われます。

## `await`を使用して非同期の未来を消費する

共有関数の呼び出し元は通常、`async T`型の未来を受け取ります。

呼び出し元がこの未来でできることは、それが完了するのを待つこと、捨てること、または後で使用するために保存することです。

`async`値の結果にアクセスするために、未来の受信者は`await`式を使用します。

例えば、上記の`Counter.read()`の結果を使用するには、まず未来を識別子`a`にバインドし、次に`await a`で基礎となる[`Nat`](../base/Nat.md)型の`n`を取得します：

```ts
let a : async Nat = Counter.read();
let n : Nat = await a;
```

1行目ではカウンターの値の未来がすぐに受け取られますが、まだそれを待機しないため、まだ自然数として使用することはできません。

2行目では、この未来を`await`して結果を取得します。これにより、未来が完了するまで実行が一時停止することがあります。

通常、これら2つのステップを1つにまとめ、非同期呼び出しを直接`await`します：

```ts
let n : Nat = await Counter.read();
```

ローカル関数呼び出しは、呼び出し先が結果を返すまで呼び出し元をブロックしますが、共有関数呼び出しは未来`f`をすぐに返し、ブロックせずに実行します。ブロックする代わりに、後で`await f`を呼び出すことで、現在の計算が一時停止し、`f`が完了するまで待機します。未来が完了すると（生成者によって）、`await p`の実行はその結果で再開されます。結果が値であれば、`await f`はその値を返します。それ以外の場合は、結果がエラーであり、`await f`はそのエラーを消費者に伝播します。

未来を2回`await`すると、同じ結果が得られます。未来に保存されているエラーも再スローされます。未来がすでに完了している場合でも、サスペンションは発生します。これにより、すべての`await`の前の状態変更とメッセージ送信がコミットされることが保証されます。

:::danger

`await`を関数の本体で使用しない関数は、原子性で実行されることが保証されます。特に、関数が実行中にアクターの状態を変更することはできません。しかし、関数が`await`を実行する場合、原子性は保証されません。`await`の周りでサスペンションと再開が行われる間、他の入力メッセージの並行処理によりアクターの状態が変更される可能性があります。非同期でない状態変更を防ぐことはプログラマの責任です。ただし、`await`前の状態変更はコミットされることに依存できます。

:::

例えば、上記の`bump()`の実装では、`count`の値を1回の原子操作でインクリメントし、読み取ることが保証されます。次の代替実装は同じ意味を持たず、アクターの別のクライアントがその操作を干渉する可能性があります。

``` ts
  public shared func bump() : async Nat {
    await inc();
    await read();
  };
```

各`await`は実行を一時停止させ、他のクライアントがアクターの状態を変更することを許可します。設計上、明示的な`await`は、干渉の可能性のあるポイントを読者に明確に示します。

## 非同期データフローのためのMopsパッケージ

- [`maf`](https://mops.one/maf) と [`mal`](https://mops.one/mal)：非同期データの配送。

- [`rxmo`](https://mops.one/rxmo)：オブザーバブルを使用したリアクティブプログラミングのためのライブラリで、非同期またはコールバックベースのコードを簡単に構成できます。
