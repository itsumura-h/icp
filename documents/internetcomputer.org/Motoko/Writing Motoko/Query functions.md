---
sidebar_position: 21
---

# クエリ関数

ICPの用語で、**update**メッセージ（呼び出しとも呼ばれます）は、呼び出されるとカニスターの状態を変更することができます。状態変更を行うには、ネットワークが変更を確定し結果を返す前に、分散されたレプリカ間で合意が必要です。合意に達することは高コストで、相対的に高い遅延が伴うプロセスです。

合意の保証を必要としないアプリケーションの部分については、ICPはより効率的なクエリ操作をサポートしています。これらは、カニスターの状態を単一のレプリカから読み取り、実行中にスナップショットを変更して結果を返すことができますが、状態を永久に変更したり、さらにメッセージを送信したりすることはできません。

## クエリ関数

Motokoでは、`query`関数を使用してクエリを実装できます。`query`キーワードは、共有アクター関数の宣言を変更し、非コミット型でより高速なクエリセマンティクスで実行されるようにします。

例えば、次の`Counter`アクターに`peek`という関数があるとします：

```ts file=../examples/CounterWithQuery.mo
persistent actor Counter {

  var count = 0;

  // ...

  public shared query func peek() : async Nat {
    count
  };

}
```

`peek()`関数は、`Counter`フロントエンドが現在のカウンター値を素早く表示するが信頼性が低い場合に使われるかもしれません。

クエリ関数は、非クエリ関数から呼び出すことができます。そのネストされた呼び出しは合意を必要とするため、ネストされたクエリ呼び出しの効率向上は最良でも控えめです。

`query`修飾子は、クエリ関数の型にも反映されます：

```ts no-repl
  peek : shared query () -> async Nat
```

以前と同様に、`query`宣言とアクター型では、`shared`キーワードを省略することができます。

:::info

クエリメソッドはアクター関数を呼び出すことができず、コードがコンパイルされるとエラーが発生します。通常の関数への呼び出しは許可されています。

:::

## 複合クエリ関数

クエリには制限があります。特に、それ自体でさらなるメッセージ（クエリを含む）を発行することはできません。

この制限に対処するため、ICPは複合クエリという別のタイプのクエリ関数をサポートしています。

通常のクエリと同様に、複合クエリによる状態変更は一時的で、孤立しており、決してコミットされることはありません。さらに、複合クエリは`async`式内で暗黙的に要求される`update`関数を含む関数を呼び出すことはできません。

通常のクエリとは異なり、複合クエリは、同じアクターおよび他のアクターに対してクエリ関数および複合クエリ関数を呼び出すことができますが、それらのアクターが同じサブネットに存在する場合に限ります。

例えば、前述の`Counter`アクターをカウンターのクラスに一般化した例を考えます。クラスの各インスタンスは、与えられたカウンターの配列の値を合計するための追加の`composite query`を提供します：

```ts file=../examples/CounterWithCompositeQuery.mo
persistent actor class Counter () {

  var count = 0;

  // ...

  public shared query func peek() : async Nat {
    count
  };

  public shared composite query func sum(counters : [Counter]) : async Nat {
    var sum = 0;
    for (counter in counters.vals())  {
      sum += await counter.peek();
    };
    sum
  }

}
```

`sum`を`composite query`として宣言することで、その引数であるカウンターの`peek`クエリを呼び出すことができます。

`update`メッセージは通常のクエリ関数を呼び出すことができますが、複合クエリ関数を呼び出すことはできません。この違いは、ICPの現在の機能によって決まっており、クエリ関数と複合クエリ関数が異なるタイプの共有関数と見なされる理由を説明しています。

なお、`composite query`修飾子は、複合クエリ関数の型にも反映されます：

```ts no-repl
  sum : shared composite query ([Counter]) -> async Nat
```

複合クエリは他の複合クエリを呼び出すことしかできないため、複合クエリがどのように呼び出されるのか疑問に思うかもしれません。

複合クエリはICP外で開始されます。通常、アプリケーション（例えばブラウザのフロントエンド）が、バックエンドアクターで複合クエリを呼び出すためのイングレスメッセージを送信します。

:::danger

インターネットコンピュータの複合クエリのセマンティクスは、複合クエリによって行われた状態変更が他のカニスター間呼び出し（再帰的クエリを含む）から隔離されることを保証します。

特に、複合クエリ呼び出しは関数終了時に状態をロールバックしますが、サブクエリやサブ複合クエリ呼び出しに状態変更を渡すことはありません。再帰的呼び出しを含む繰り返し呼び出しは、状態変更を累積する呼び出しとは異なるセマンティクスを持ちます。

順次呼び出しにおいて、前のクエリの内部状態変更は後続のクエリに影響を与えることはなく、クエリは囲む複合クエリによって行われたローカルの状態変更を観察することもありません。複合クエリによって行われたローカル状態変更は呼び出し間で保持され、最終的に複合クエリから退出する際にロールバックされます。

このセマンティクスは、通常の命令型プログラミングに慣れているユーザーにとっては驚くべき挙動となることがあります。

以下の例を考えてみましょう。この例には、クエリ`q`と複合クエリ`cq`を呼び出す複合クエリ`test`が含まれています。

```ts no-repl file=../examples/CompositeSemantics.mo
persistent actor Composites {

  var state = 0;

  // ...

  public shared query func q() : async Nat {
    let s = state;
    state += 10;
    s
  };

  public shared composite query func cq() : async Nat {
    let s = state;
    state += 100;
    s
  };

  public shared composite query func test() :
    async {s0 : Nat; s1 : Nat; s2 : Nat; s3 : Nat } {
    let s0 = state;
    state += 1000;
    let s1 = await q();
    state += 1000;
    let s2 = await cq();
    state += 1000;
    let s3 = state;
    {s0; s1; s2; s3}
  };

}
```

`state`が`0`のとき、`test`を呼び出すと次の結果が返ります：

```
{s0 = 0; s1 = 0; s2 = 0; s3 = 3_000}
```

これは、`state`へのローカルな更新がどの呼び出し元にも呼び出し先にも見えないためです。

:::

<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />
