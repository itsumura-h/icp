---
sidebar_position: 27
---

# 不完全なコードの記述

プログラムの途中で、実行パスが欠けていたり、無効な状態である不完全なバージョンを実行したい場合があります。

このような状況に対応するために、Motoko では以下の `xxx`、`nyi`、`unreachable` 関数をベースの `Prelude` ライブラリから提供しています。これらはすべて、[一般的なトラップメカニズム](../getting-started/basic-concepts.md#traps)の簡単なラッパーです。

## 短期的な穴

以下のようにプレリュードをインポートしたと仮定します：

```ts no-repl
import P "mo:base/Prelude";
```

欠けている式を次のように埋めることができます：

```ts no-repl
P.xxx()
```

`xxx()` の式は `None` 型であり、これは他のすべての型のサブタイプです。つまり、この式はコードの中で短期的な隙間を埋めることができます。
`xxx()` は実行時にトラップを発生させます。

## 長期的な穴

慣習的に、長期的な穴は「未実装」(`nyi`) の機能と見なすことができ、プレリュードモジュールの同様の関数でそれを示すことができます：

```ts no-repl
P.nyi()
```

`xxx()` と同様に、`nyi()` も `None` 型であり、したがって他のすべての型のサブタイプであり、実行時にトラップを発生させます。

## 到達不能なコード

時には、前のプログラムのロジックによって実行されることが決してないコードを提供する必要があることがあります。

到達不能なコードを文書化するために、プレリュードの `unreachable` 関数を使用できます：

```ts no-repl
P.unreachable()
```

`unreachable()` も `None` 型であり、したがって他のすべての型のサブタイプであり、（予期しない）実行時にトラップを発生させます。

<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />
