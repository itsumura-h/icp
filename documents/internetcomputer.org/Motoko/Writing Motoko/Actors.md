---
sidebar_position: 2
---

# アクター

インターネットコンピュータのプログラミングモデルは、非同期メッセージングでCandid値をエンコードしたバイナリデータを送信することによって通信するメモリ分離されたカニスターで構成されています。カニスターはメッセージを一度に1つずつ処理し、競合状態を防ぎます。カニスターは、発行するインターカニスター間のメッセージの結果に基づいて実行する必要があることを登録するためにコールバックを使用します。

Motokoは、ICP上のカニスタースマートコントラクトを含む**サービス**を表現するための**アクター型**プログラミングモデルを開発者に提供します。各カニスターは型付きアクターとして表現され、アクターの型はそのアクターが処理できるメッセージをリストします。各メッセージは型付き非同期関数として抽象化されます。アクター型からCandid型への変換は、インターネットコンピュータの基盤となる生のバイナリデータに構造を与えます。アクターはオブジェクトに似ていますが、その状態は完全に分離されており、世界とのやり取りはすべて非同期メッセージングを介して行われ、メッセージは一度に1つずつ処理されます。これは、並行するアクターによって並列に発行された場合でも同様です。

## アクター

アクターはオブジェクトに似ていますが、次の点で異なります：

- 状態は完全に分離されています。

- 世界とのやり取りは完全に非同期メッセージングを通じて行われます。

- メッセージは並行するアクターによって並列に発行された場合でも、一度に1つずつ処理されます。

アクターとの通信はすべて、インターネットコンピュータのメッセージングプロトコルを使用して非同期にネットワークを介して行われます。アクターのメッセージは順番に処理されるため、状態変更は競合状態を招くことはありません、`await`式で明示的に許可されている場合を除きます。

インターネットコンピュータは、送信された各メッセージが応答を受け取ることを保証します。応答は、成功とともに値を返すか、エラーを返します。エラーは、受信カニスターによるメッセージの明示的な拒否、ゼロ除算などの不正な命令によるトラップ、または分散やリソース制約によるシステムエラーである可能性があります。例えば、システムエラーは、受信者の一時的または恒久的な利用不可である場合です（受信アクターが過負荷になっているか削除されている場合など）。

Motokoでは、アクターには専用の構文と型があります：

- メッセージングは、未来を返す**共有関数**によって処理されます。共有関数はリモート呼び出し可能であり、追加の制約があります：その引数と戻り値は共有型でなければなりません。共有型は、イミュータブルデータ、アクター参照、共有関数参照を含む型のサブセットですが、ローカル関数やミュータブルデータの参照は除外されます。

- 未来（`f`）は、特別な型`async T`の値で、`T`は任意の型です。

- `f`が完了するのを待つことは、`await f`を使って型`T`の値を取得することによって表現されます。例えば、オブジェクトやミュータブル配列を送信することによって共有状態を導入しないようにするために、共有関数を通じて送信できるデータは、イミュータブルで共有型に制限されています。

- すべての状態はアクターまたはアクタークラス内でカプセル化されるべきです。メインのアクターファイルは、インポートから始まり、その後アクターまたはアクタークラスの定義が続きます。

## アクターの定義

以下のアクター宣言を考えてみましょう：

``` ts
persistent actor Counter {

  var count = 0;

  public shared func inc() : async () { count += 1 };

  public shared func read() : async Nat { count };

  public shared func bump() : async Nat {
    count += 1;
    count;
  };
};
```

`Counter`アクターは1つのフィールドと3つの公開され、共有関数を宣言しています：

- フィールド`count`はミュータブルで、ゼロで初期化され、暗黙的に`private`です。

- 関数`inc()`は非同期でカウンターをインクリメントし、同期のために`async ()`型の未来を返します。

- 関数`read()`は非同期でカウンターの値を読み取り、`async Nat`型の未来を返してその値を含みます。

- 関数`bump()`は非同期でカウンターをインクリメントし、値を読み取ります。

共有関数はローカル関数とは異なり、リモート呼び出し可能であり、追加の制約があります。引数と戻り値は共有型でなければなりません。共有型は、イミュータブルデータ、アクター参照、共有関数参照を含み、ローカル関数やミュータブルデータの参照を除外します。すべてのアクターとのやり取りは非同期であるため、アクターの関数は未来（`async T`型）を返さなければなりません。

`Counter`アクターの状態（`count`）を読み取ったり変更したりする唯一の方法は、その共有関数を通じて行われます。

`async T`型の値は未来です。未来の生成者は、結果を返すときにその未来を完了します。結果は、値またはエラーです。

オブジェクトやモジュールとは異なり、アクターは関数のみを公開でき、これらの関数は`shared`でなければなりません。このため、Motokoでは公開されるアクター関数に`shared`修飾子を省略でき、より簡潔なアクター宣言が可能になります：

``` ts
persistent actor Counter {

  stable var count = 0;

  public func inc() : async () { count += 1 };

  public func read() : async Nat { count };

  public func bump() : async Nat {
    count += 1;
    count;
  };
};
```

現在、共有関数を宣言できる場所はアクターまたはアクタークラスの本体のみです。この制限にもかかわらず、共有関数はMotokoで依然として第一級の値であり、引数や結果として渡したり、データ構造に格納したりできます。

共有関数の型は、共有関数型を使用して指定します。例えば、`inc`の値は`shared () → async Nat`型であり、他のサービスにスタンドアロンのコールバックとして提供できます。

## アクター型

オブジェクトがオブジェクト型を持つように、アクターはアクター型を持ちます。上記の`Counter`例には、次の型があります：

``` motoko no-repl
actor {
  inc  : shared () -> async ();
  read : shared () -> async Nat;
  bump : shared () -> async Nat;
}
```

オブジェクトやモジュールとは異なり、アクターは関数のみを公開でき、これらの関数は`shared`でなければなりません。現在、共有関数を宣言できる場所はアクターまたはアクタークラスの本体のみです。この制限にもかかわらず、共有関数はMotokoで依然として第一級の値であり、引数や結果として渡したり、データ構造に格納したりできます。

`shared`修飾子はアクターのすべてのメンバーに必要です。Motokoはそれらを表示時に省略し、アクター型を作成する際には省略することを許可します。

そのため、前述の型は次のように簡潔に表現できます：

``` motoko no-repl
actor {
  inc  : () -> async ();
  read : () -> async Nat;
  bump : () -> async Nat;
}
```

オブジェクト型と同様に、アクター型はサブタイプをサポートしています：アクター型は、より一般的な型のサブタイプであり、より一般的な型の関数で少ない機能を提供します。

## 非同期動作

他の現代的なプログラミング言語と同様に、Motokoはコンポーネント間での**非同期**通信のためのエルゴノミクスな構文を提供します。

Motokoの場合、通信する各コンポーネントはアクターです。アクターの使用例として、この3行のプログラムを考えてみましょう：

```motoko no-repl
let result1 = service1.computeAnswer(params);
let result2 = service2.computeAnswer(params);
finalStep(await result1, await result2)
```

このプログラムの動作は次のように要約できます：

1. プログラムは2つの異なるサービスにリクエストを送ります（1行目と2行目）。それぞれのサービスはMotokoアクターまたは別の言語で実装されたカニスタースマートコントラクトとして実装されています。

2. プログラムは、各結果が準備できるのを待ちます（3行目）。各結果値に対して`await`を使用して待機します。

3. プログラムは最終ステップで両方の結果を使用します（3行目）。`finalStep`関数を呼び出します。

サービスは、全体的な遅延を減らすために、互いに待機することなく実行が**インターレーブ**されます。この方法で遅延を減らそうとすると、特別な言語サポートがない場合、そのようなインターレービングは明確さとシンプルさを犠牲にすることになります。

インターレーブされた実行がない場合、例えば、上記のように1回の呼び出ししかない場合でも、プログラミング抽象化は依然として明確さとシンプルさを保ちます。それは、プログラムを変換する場所をコンパイラに示すことで、プログラマがプログラムのロジックをシステムのメッセージループに合わせて変形する必要をなくすためです。

上記の例では、プログラムは3行目で`await`を使用して、このインターレーブ動作をシンプルに表現しています。

この抽象化がない他のプログラミング言語では、開発者は単にこれらの2つの関数を直接呼び出すのではなく、非常に高度なプログラミングパターンを使用し、システム提供の「イベントハンドラー」に「コールバック関数」を登録することになります。それぞれのコールバックは、回答が準備できたときに発生する非同期イベントを処理します。この種のシステムレベルのプログラミングは強力ですが、非常にエラーが発生しやすく、ハイレベルなデータフローを低レベルのシステムイベントに分解し、共有状態を介して通信することになります。

## トラップとコミットポイント

トラップは、ゼロ除算、範囲外配列インデックス、数値オーバーフロー、サイクル枯渇、またはアサーション失敗などのエラーによって引き起こされる回復不能なランタイムエラーです。

`await`式を実行しない共有関数呼び出しは、決して停止せず、原子性で実行されます。`await`式を含まない共有関数は、構文的に原子性を持ちます。

### コミットポイント

実行中にトラップが発生した原子性のある共有関数は、その状態を変更したり環境に影響を与えたりすることはありません。変更された状態は元に戻され、送信したメッセージは取り消されます。実際、すべての状態変更とメッセージ送信は実行中に一時的です。それらは、成功したコミットポイントに到達した後にのみ確定されます。

一時的な状態変更とメッセージ送信が確定的にコミットされるポイントは次のとおりです：

- 結果を生成することによる共有関数からの暗黙の終了。

- `return`や`throw`式を使った明示的な終了。

- 明示的な`await`式。

### トラップ

トラップは、最後のコミットポイント以降に行った変更のみを取り消します。特に、複数の`await`を含む非原子的な関数では、トラップは最後の`await`以降に行った変更のみを取り消し、それ以前の影響はすでに確定しており、元に戻すことはできません。

以下の状態を持つ`Atomicity`アクターを考えてみましょう：

``` ts
actor Atomicity {

  var s = 0;
  var pinged = false;

  public func ping() : async () {
    pinged := true;
  };

  // an atomic method
  public func atomic() : async () {
    s := 1;
    ignore ping();
    ignore 0/0; // trap!
  };

  // a non-atomic method
  public func nonAtomic() : async () {
    s := 1;
    let f = ping(); // this will not be rolled back!
    s := 2;
    await f;
    s := 3; // this will not be rolled back!
    await f;
    ignore 0/0; // trap!
  };

};
```

共有関数`atomic()`を呼び出すと、トラップが発生しエラーになります。トラップが発生すると、ミュータブル変数`s`の値は`1`ではなく`0`となり、変数`pinged`の値は`true`ではなく`false`になります。これは、トラップが`await`を実行する前、または`atomic`メソッドが結果で終了する前に発生したからです。`atomic`が`ping()`を呼び出しても、`ping()`は次のコミットポイントまでキューに積まれます。

共有関数`nonAtomic()`を呼び出すと、トラップのためにエラーが発生します。この関数では、トラップが変数`s`に`3`、`pinged`に`true`という値を残します。これは、各`await`が前の副作用をコミットし、メッセージ送信を含むためです。`f`が2回目の`await`で完了しても、この`await`は状態をコミットし、実行を一時停止し、他のメッセージの並列処理を許可します。
