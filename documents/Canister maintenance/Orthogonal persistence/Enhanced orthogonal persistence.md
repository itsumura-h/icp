---
sidebar_position: 2
---

# 強化された直交永続性

強化された直交永続性は、Motokoにおける効率的でスケーラブルな直交永続性のビジョンを実現しています。この設計は以下を組み合わせています：
* **安定したヒープ**：プログラムのメインメモリをカニスターのアップグレードを跨いで永続化。
* **64ビットヒープ**：大規模な永続化のためにメインメモリを64ビットに拡張。

その結果、二次ストレージ（明示的な安定メモリ、専用の安定データ構造、データベースのようなストレージ抽象化）はもはや必要ありません。Motokoの開発者は、プログラムのバージョン変更を跨いで自動的に永続化され保持される通常のオブジェクト指向プログラム構造を直接扱うことができます。

### 有効化
強化された直交永続性は現在**ベータテスト**として、コンパイラフラグ `--enhanced-orthogonal-persistence` を使用して提供されています。

`dfx`で強化された直交永続性を有効化するには、以下のコマンドライン引数を `dfx.json` に指定する必要があります：

```
...
    "type" : "motoko"
    ...
    "args" : "--enhanced-orthogonal-persistence"
...
```

:::tip
強化された直交永続性を使用している場合でも、アプリケーションのアップグレードを徹底的にテストすることを強くお勧めします。
また、アップグレードが失敗した場合にデータを回復するためのバックアップ手段を準備しておくことが推奨されます。例えば、コントローラ権限によるデータクエリ呼び出しを通じて。
:::

現在、32ビットのメインメモリとCandidの安定化を使用した[古典的な直交永続性](classical.md)がデフォルトモードとして残っています。比較については[直交永続性モード](modes.md)を参照してください。

## 設計
Motokoの既存の直交永続性と比較して、この設計は以下を提供します：
* **パフォーマンス**：新しいプログラムバージョンは既存のメインメモリから直接再開し、メモリ互換のデータにアクセスできます。
* **スケーラビリティ**：アップグレードメカニズムは大きなヒープにも対応し、シリアライズと比較して、ICの命令制限に達することはありません。

明示的な安定メモリの使用と比較して、この設計は以下の点で改善されます：
* **シンプルさ**：開発者は明示的な安定メモリを扱う必要がありません。
* **パフォーマンス**：別々の安定メモリへのコピーが不要です。

強化された直交永続性は以下の主要な特性に基づいています：
* アップグレード時にICのメインメモリを保持する拡張。
* ICでの64ビットメインメモリのサポート。
* 新しいコンパイル済みプログラムバージョンに対して不変な長期メモリレイアウト。
* 各カニスターのアップグレード時に実行される高速なメモリ互換チェック。
* 分割ヒープを使用したインクリメンタルガーベジコレクション。

### 互換性チェック
アップグレードは、新しいプログラムバージョンが古いバージョンと互換性がある場合にのみ許可されます。ランタイムシステムはメモリ構造が互換であることを保証します。

不変型の互換性のある変更は、Motokoのサブタイプ関係に大部分で類似しており、以下の柔軟性があります：
* アクターのフィールドの追加または削除。
* アクターのフィールドの可変性の変更（`let` から `var` への変更およびその逆）。
* オブジェクトフィールドの削除。
* バリアントフィールドの追加。
* `Nat` から `Int` への変更。
* 共有関数のパラメータの反変と戻り値の共変のサポート。
* Motokoのサブタイピングルールに従ったその他の変更。

ランタイムシステムは、アップグレード時に移行互換性をチェックし、満たされない場合はアップグレードをロールバックします。この互換性チェックは、ユーザーが回避可能な `dfx` の警告に加えて追加の安全措置として機能します。

さらに複雑な変更は、プログラム的な指示を使用して実行できます。[明示的な移行](../upgrades.md#explicit-migration)を参照してください。

### 移行パス
古いシリアライズベースの安定化から新しい永続ヒープへの移行時、古いデータは安定メモリから最後にデシリアライズされ、その後新しい永続ヒープレイアウトに配置されます。永続ヒープで操作を開始すると、シリアライズベースの永続性へのダウングレード試行が防止されます。

#### グラフコピー方式の安定化
将来的に永続メモリレイアウトを変更する必要がある場合、ランタイムシステムはグラフコピー方式を使用して定義されたデータ形式で安定メモリへのシリアライズとデシリアライズをサポートします。シリアライズとデシリアライズは、指令および作業セットの制限を超えて、大きなデータを複数のメッセージに分割して実行します。このプロセス中、他のメッセージはブロックされ、カニスターの所有者または管理者のみがこのプロセスを開始できます。

これはMotokoの実装が内部メモリレイアウトを変更する場合にのみ必要です。ユーザーにはこの移行を明示的に開始するよう指示されます。

#### 使用法
グラフコピー方式の安定化は、以下の3つのステップで実行できます：

1. アップグレード前に明示的な安定化を開始：

```sh
dfx canister call CANISTER_ID __motoko_stabilize_before_upgrade "()"
```

2. 実際のアップグレードを実行：

```sh
dfx deploy CANISTER_ID
```

3. アップグレード後に明示的な非安定化を完了：

```sh
dfx canister call CANISTER_ID __motoko_destabilize_after_upgrade "()"
```

備考：
* 明示的な安定化、アップグレード、または非安定化中に「dfx」エラー「リクエストがタイムアウトしました。」が表示された場合、完了するまで呼び出しを繰り返すことができます。
* ステップ3（明示的な非安定化）は、対応する操作がアップグレードメッセージに収まる場合は必要ないことがあります。

### 古い安定メモリ
古い安定メモリは、新しいサポートを使用しても、引き続きセカンダリ（レガシー）メモリとして利用可能です。そのため、安定領域は直交永続性と組み合わせて使用できます。

## ICメインメモリの保持

ICは、新しいアップグレードオプション `wasm_memory_persistence` を導入して、カニスターのWasmメインメモリの保持を制御します。
* `wasm_memory_persistence = opt keep` はWasmメインメモリを保持し、Motokoの強化された直交永続性に必要です。ICは古典的な永続性を使用するカニスターにはこのオプションを使用できません。
* `wasm_memory_persistence = null` は古典的な永続性を使用し、メインメモリを置き換えます。しかし、強化された直交永続性用にメインメモリが誤って削除されないように安全チェックが実施されます。
* 他のオプション `replace` は、強化された直交永続性でもWasmメインメモリを削除するため、データ損失の可能性があり、推奨されません。
