---
sidebar_position: 3
---

# 安定変数とアップグレードメソッド

Motoko の重要な特徴の一つは、プログラムの状態をユーザーの明示的な指示なしで自動的に保持する「**直交的永続性**」の能力です。これにより、トランザクションを超えた永続性だけでなく、カニスターのアップグレードにも対応できます。この目的のために、Motoko にはアップグレードを高度に管理するコンパイラとランタイムシステムが組み込まれており、新しいプログラムバージョンは前のバージョンによって残された状態を引き継ぐことができます。その結果、Motoko のデータ永続性は単純ではありませんが、データの破損や損失を防ぎ、同時に効率的です。アップグレードを超えて状態を保持するために、データベース、安定メモリ API、または安定データ構造は必要ありません。代わりに、単純な `stable` キーワードを使うだけで、共有を使ったり、深い複雑さを持ったり、サイクルを含む構造でも、データ構造を永続的に宣言できます。

これは、IC 上でサポートされている他の言語とは大きく異なります。他の言語では、標準の言語実装を使用しており、直交的永続性を念頭に置いて設計されていないため、再コンパイルや実行時にメモリ構造が制御されずに再配置されることがあります。これに対して、他の言語では、プログラマーは明示的に安定メモリや特殊な安定データ構造を使用してアップグレード間でデータを救出する必要があります。Motoko と異なり、このアプローチは面倒であり、安全でない上に非効率的です。安定データ構造を使用するのと比べて、Motoko の直交的永続性はより自然なデータモデリングを可能にし、データアクセスを大幅に高速化し、最終的にはより効率的なプログラムを実現します。

## 安定変数の宣言

アクター内で、プログラムのどの部分が永続的であるか（すなわち、アップグレードを超えて生き残る部分）を構成し、どの部分が一時的であるか（アップグレード時にリセットされる部分）を構成できます。

より正確には、アクター内の各 `let` および `var` 変数宣言で、変数が `stable`（安定）か `transient`（一時的）かを指定できます。修飾子を指定しない場合、変数はデフォルトで `transient` と見なされます。

修飾子の意味は次の通りです：
* `stable` は、その安定アクター変数から直接的または間接的に到達可能なすべての値が永続的であり、アップグレードを超えて自動的に保持されることを意味します。これは、プログラムの状態の主要な選択肢です。
* `transient` は、アップグレード時に変数が再初期化されることを意味します。この変数が参照する値は破棄される可能性がありますが、値が他の安定な変数から到達可能であれば、破棄されません。`transient` は、一時的な状態や高階型（例えば、ローカル関数参照）の参照にのみ使用されます。[安定型](#stable-types)を参照してください。

:::note

Motoko の以前のバージョン（0.13.4 以前）では、`transient` の代わりに `flexible` キーワードを使用していました。両方のキーワードは互換性がありますが、将来的にはレガシーの `flexible` キーワードは非推奨になる可能性があります。

:::

以下は、カウンターの値を保持したままアップグレードできる安定したカウンターを宣言する簡単な例です：

```ts file=../examples/StableCounter.mo
actor Counter {

  stable var value = 0;

  public func inc() : async Nat {
    value += 1;
    return value;
  };
}
```

Motoko v0.13.5 以降、`actor` キーワードの前に `persistent` キーワードを追加することで、アクターまたはアクタークラスのすべての `let` と `var` 宣言が暗黙的に `stable` として宣言されます。`transient` 変数のみが明示的に `transient` と宣言する必要があります。`persistent` アクターを使用することで、意図しないデータ損失を避けることができます。これはアクターおよびアクタークラスの推奨される宣言構文です。非 `persistent` 宣言は後方互換性のために提供されています。

Motoko v0.13.5 以降、上記の `StableCounter` を宣言する推奨方法は次の通りです：

```ts file=../examples/PersistentCounter.mo
persistent actor Counter {

  var value = 0; // implicitly stable!

  public func inc() : async Nat {
    value += 1;
    value;
  };
}
```

:::note

`stable`、`transient`（またはレガシーの `flexible`）修飾子は、**アクターのフィールド**でのみ使用できます。他の場所ではこれらの修飾子を使用することはできません。

:::

最初にカニスターをコンパイルしてデプロイすると、アクター内のすべての一時的および安定変数が順番に初期化されます。`upgrade` モードを使用してカニスターをデプロイすると、アクターの前のバージョンに存在したすべての安定変数が以前の値で事前に初期化されます。安定変数が以前の値で初期化された後、残りの一時的および新たに追加された安定変数が順番に初期化されます。

:::danger
アップグレードを超えて生き残るべき変数は、必ず `stable` と宣言することを忘れないでください。修飾子が宣言されていない場合、デフォルトは `transient` です。
単純な予防措置として、アクター全体またはアクタークラスを `persistent` と宣言してください。
:::

## 永続モード

Motoko には、直交的永続性の実装が2種類あります。詳細は [永続モード](orthogonal-persistence/modes.md) を参照してください。

## 安定型

コンパイラは、安定変数がアップグレード後に置き換えられたプログラムでも互換性があり、意味を持つことを保証する必要があるため、すべての `stable` 変数は安定型を持たなければなりません。型は安定型である場合、その型から `var` 修飾子を除いた型が共有されている型です。

安定型と共有型の違いは、前者が変更をサポートすることです。共有型と同様に、安定型は第一級データに制限され、ローカル関数やローカル関数から構築された構造（例えば、クラスインスタンス）は含まれません。この関数の除外は、データとコードの両方で構成される関数値の意味をアップグレードを超えて保存することが容易でないため、必要です。単純なデータの意味は、変更可能でも不可能でも保存できます。

:::note

一般的に、クラスはローカル関数を含むため安定ではありません。ただし、安定データのプレーンなレコードは、安定したオブジェクト型の特別なケースです。さらに、アクターや共有関数への参照も安定しており、アップグレードを超えてその値を保存できます。例えば、サービスに登録されているアクターのセットや共有関数のコールバックの状態レコードを保存することができます。

:::

## 非安定型を安定型に変換する

安定型でない変数を安定型にするためには、次の2つの方法があります：

1. 型に `stable` モジュールを使用する（例えば、以下のように）：

  - [StableBuffer](https://github.com/canscale/StableBuffer)
  - [StableHashMap](https://github.com/canscale/StableHashMap)
  - [StableRBTree](https://github.com/canscale/StableRBTree)

:::note
Rust CDK の安定データ構造とは異なり、これらのモジュールは安定メモリを使用せず、直交的永続性に依存しています。Motoko での「安定」の形容詞は、単に安定型を示しています。
:::

2. 安定型で状態を抽出し、非安定型でラップします。

例えば、安定型 `TemperatureSeries` は永続データをカバーし、非安定型 `Weather` はこれを追加のメソッド（ローカル関数型）でラップします。

```ts no-repl file=../examples/WeatherActor.mo
persistent actor {
  type TemperatureSeries = [Float];

  class Weather(temperatures : TemperatureSeries) {
    public func averageTemperature() : Float {
      var sum = 0.0;
      var count = 0.0;
      for (value in temperatures.vals()) {
        sum += value;
        count += 1;
      };
      return sum / count;
    };
  };

  var temperatures : TemperatureSeries = [30.0, 31.5, 29.2];
  transient var weather = Weather(temperatures);
};
```

3. __推奨しませんが非推奨__: [アップグレード前後フック](#preupgrade-and-postupgrade-system-methods) を使用して、アップグレード中に非安定型を安定型にコピーすることができます。この方法はエラーが発生しやすく、大規模データにはスケーラブルではありません。**ベストプラクティスとして、可能であればこれらの方法は避けるべきです。** 概念的にも直交的永続性の考え方にうまく合致しません。

## 安定型のシグネチャ

アクター内の安定変数宣言の集合は、安定シグネチャにまとめることができます。

アクターの安定シグネチャのテキスト表現は、Motoko アクター型の内部構造に似ています：

```ts no-repl
actor {
  stable x : Nat;
  stable var y : Int;
  stable z : [var Nat];
};
```

これは、アクターの安定フィールドの名前、型、および変更可能性を指定し、必要に応じて関連する Motoko 型宣言が前に付けられる場合もあります。

:::tip

メインアクターまたはアクタークラスの安定シグネチャを `.most` ファイルに出力するには、`moc` コンパイラオプション `--stable-types` を使用します。自分で `.most` ファイルを作成する必要はありません。

:::

安定シグネチャ `<stab-sig1>` は `<stab-sig2>` と互換性がある場合、次のいずれかの条件が満たされます：

- `<stab-sig2>` に安定フィールド `<id>` が含まれていない。
- `<stab-sig>` に一致する安定フィールド `<id> : U` があり、`T <: U` である。

`<stab-sig1>` は古いバージョンのシグネチャであり、`<stab-sig2>` は新しいバージョンのシグネチャです。

安定フィールドのサブタイプ条件は、最終的なフィールドの値がアップグレードコード内でそのフィールドの初期値として消費できることを保証します。

:::tip

2つの `.most` ファイルに含まれる安定シグネチャの安定互換性を確認するには、`moc` コンパイラオプション `--stable-compatible file1.most file2.most` を使用します。

:::

## アップグレードの安全性

カニスターをアップグレードする際には、以下のことを確認することが重要です：

-   安定宣言で互換性のない変更を導入していないこと。
-   Candid インターフェースの変更によってクライアントが壊れないこと。

[

強化された直交的永続性](orthogonal-persistence/enhanced.md)により、Motoko はアップグレード試行中に安定宣言の互換性のない変更を拒否します。
さらに、`dfx` はアップグレードを試みる前にこの2つの条件をチェックし、ユーザーに適切に警告を出します。

Motoko カニスターのアップグレードは、次の条件が満たされていれば安全です：

-  カニスターの Candid インターフェースは Candid サブタイプに進化する。
-  カニスターの Motoko 安定シグネチャは安定互換性のあるものに進化する。

:::danger
[古典的な直交的永続性](orthogonal-persistence/classical.md) では、リソース制約によりアップグレードが失敗する可能性があります。これは問題であり、カニスターはその後アップグレードできなくなります。そのため、アップグレードのスケーラビリティを十分にテストすることが強く推奨されます。強化された直交的永続性はこの問題を解決します。
:::

:::tip

2つのサービス間で有効な Candid サブタイピングを確認するには、[`didc` ツール](https://github.com/dfinity/candid)を使用して `check file1.did file2.did` として実行します。

:::

## デプロイされたアクターやカニスターのアップグレード

Motoko アクターを適切な `stable` 変数でデプロイした後、`dfx deploy` コマンドを使用して、すでにデプロイされたバージョンをアップグレードできます。デプロイされたカニスターのアップグレードに関する情報は、[カニスタースマートコントラクトのアップグレード](/docs/current/developer-docs/smart-contracts/maintain/upgrade) を参照してください。

`dfx deploy` はインターフェースの互換性を確認し、もし互換性がない場合、このメッセージを表示して続行するかどうかを尋ねます：

```
You are making a BREAKING change. Other canisters or frontend clients relying on your canister may stop working.
```

さらに、Motoko の強化された直交的永続性は、ランタイムシステムで安定データが互換性があることを保証する追加のセーフガードを実装しており、データの破損や誤解釈を防ぎます。また、`dfx` は安定変数が削除されることに対しても警告します。

## データ移行

新しいプログラムバージョンでデータ表現が変更されることがあります。直交的永続性において、言語が新しいバージョンへの柔軟なデータ移行を許可できることが重要です。

Motoko は2種類のデータ移行をサポートしています：暗黙の移行と明示的な移行です。

### 暗黙の移行

新しいプログラムバージョンが古いバージョンと安定互換性がある場合、これが自動的にサポートされます。Motoko のランタイムシステムは、アップグレード時に移行を自動的に処理します。

より正確には、次の変更は暗黙的に移行されます：
* アクターのフィールドの追加または削除。
* アクターのフィールドの変更可能性の変更。
* レコードフィールドの削除。
* バリアントフィールドの追加。
* `Nat` を `Int` に変更。
* 共有関数の引数の逆変換と返り値の共変性。
* Motoko のサブタイピングルールで許可される変更。

### 明示的な移行

より複雑な移行はユーザー定義の機能で実行できます。

この目的のため、3ステップのアプローチを取ります：
1. 必要な型の新しい変数を導入し、古い宣言を保持します。
2. アップグレード時に古い変数から新しい変数へ状態をコピーするロジックを書きます。
3. すべてのデータが移行された後、古い宣言を削除します。

詳細については、[明示的な移行の例](compatibility.md#explicit-migration)をご覧ください。

## レガシー機能

次の機能は、歴史的理由および後方互換性のために保持されています：

### アップグレード前後のシステムメソッド

:::danger
アップグレード前後のシステムメソッドの使用は推奨されません。エラーが発生しやすく、カニスターが使用できなくなる可能性があります。特に、`preupgrade` メソッドがトラップし、他の手段でトラップを防げない場合、カニスターはアップグレードできなくなる可能性があります。ベストプラクティスとして、これらのメソッドは可能な限り避けるべきです。
:::

Motoko はユーザー定義のアップグレードフックをサポートしており、アップグレードの直前と直後に実行されます。これらのフックを使用すると、アップグレード時に追加のロジックをトリガーできます。
これらのフックは、`system` 関数として特別な名前 `preupgrade` と `postupgrade` で宣言されます。両方の関数は `: () → ()` 型である必要があります。

:::danger
`preupgrade` がトラップを引き起こしたり、命令制限に達したり、他の IC 計算制限に達したりすると、アップグレードは失敗し、カニスターは現在のバージョンにとどまります。
:::

:::tip
`postupgrade` は必要ありません。アクター内で初期化式（例えば非安定な `let` 式や式文）を導入することで同じ効果を得ることができます。
:::

### 安定メモリと安定領域

安定メモリは、直交的永続性を実装していない言語でのアップグレードを可能にするために IC 上で導入されました。Motoko の古典的永続性や、Motoko 以外の他の言語にも該当します。

安定メモリと安定領域は、直交的永続性と組み合わせて使用できますが、強化された直交的永続性と将来的な IC 上の大容量メインメモリを考慮すると、実際にはほとんど必要ないと言えます。
