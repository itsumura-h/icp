---
sidebar_position: 17
---

# 可変状態

Motoko の各アクターは内部の可変状態を使用できますが、それを直接共有することはできません。

不変データはアクター間で[共有](sharing.md)することができ、また、他のアクターの外部エントリポイントを通じて共有可能な関数として処理できます。共有可能なデータとは異なり、Motoko の設計における重要な不変条件は、可変データはそれを割り当てたアクター専用であり、遠隔で共有されることはないということです。

## 不変変数と可変変数

`var` 構文は、宣言ブロック内で可変変数を宣言します：

```ts name=init
let text  : Text = "abc";
let num  : Nat = 30;

var pair : (Text, Nat) = (text, num);
var text2 : Text = text;
```

上記の宣言リストは4つの変数を宣言します。最初の2つの変数（`text` と `num`）はレキシカルスコープで不変の変数です。最後の2つの変数（`pair` と `text2`）はレキシカルスコープで可変の変数です。

## 可変メモリへの代入

可変変数には代入が可能で、不変変数には代入できません。

上記の `Text` や `num` に新しい値を代入しようとすると、これらの変数が不変であるため、静的型エラーが発生します。

可変変数 `pair` と `text2` の値を更新するには、代入構文 `:=` を使用します。以下のように記述できます：

```ts no-repl
text2 := text2 # "xyz";
pair := (text2, pair.1);
pair
```

上記の例では、各変数が現在の値に基づいて簡単な更新ルールを適用して更新されます。同様に、アクターはそのプライベートな可変変数に対して更新を行い、上記と同じ代入構文を使用していきます。

### 特殊な代入操作

代入操作 `:=` は一般的で、すべての型に対して機能します。

Motoko には、代入とバイナリ操作を組み合わせた特殊な代入操作があります。代入される値は、指定されたオペランドと代入される変数の現在の内容に対してバイナリ操作を適用します。

例えば、数値は代入と加算の組み合わせを許可します：

```ts
var num2 = 2;
num2 += 40;
num2
```

2行目の後、変数 `num2` は予想通り `42` を保持します。

Motoko には他の組み合わせもあります。例えば、上記で `text2` を更新する行を次のように簡潔に書き直すことができます：

```ts no-repl
text2 #= "xyz";
text2
```

`+=` と同様に、この組み合わせ形は、特殊な代入演算子 `#=` の右側に代入変数の名前を繰り返し書くことを避けます。

[代入演算子](../reference/language-manual#assignment-operators)の完全な表では、数値、論理、テキストの演算がそれぞれ適切な型（数値、ブール値、テキスト）に対して行われます。

## 可変メモリからの読み取り

変数を更新した後は、その可変の内容から読み取らなければなりません。これには特別な構文は必要ありません。

可変変数の使用は、不変変数の使用と同じように見えますが、動作は異なります。実際、その意味はより複雑です。多くの他の言語と同様に、使用される構文は、その変数によって識別されたメモリセルにアクセスし、現在の値を取得するメモリ効果を隠します。関数型の伝統を持つ他の言語では、これらの効果が構文的に公開されることが一般的です。

## `var` と `let` による変数の束縛

次の2つの変数宣言を考えます。これらは似ていますが異なります：

```ts
let x : Nat = 0
```

```ts
var x : Nat = 0
```

構文の違いは、変数 `x` を定義するために使用するキーワード `let` と `var` の違いだけです。どちらの場合でも、プログラムは `x` を `0` に初期化します。

しかし、これらのプログラムは異なる意味を持ち、大きなプログラムの文脈では、`x` の各出現の意味に影響を与えます。

最初のプログラムでは、`let` を使うと、各出現が `0` を意味します。各出現を `0` に置き換えてもプログラムの意味は変わりません。

2番目のプログラムでは、`var` を使うと、各出現が「可変メモリセル `x` の現在の値を読み取って返す」という意味になります。この場合、各出現の値は、可変メモリセル `x` の動的状態によって決まります。

上記の定義から分かるように、`let` と `var` による変数の意味には根本的な違いがあります。

大きなプログラムでは、両方の種類の変数が役立ちますが、どちらか一方がもう一方の良い代替となるわけではありません。しかし、`let` による変数はより基本的です。

例えば、`x` を最初に `0` を保持する可変変数として宣言する代わりに、`y` という不変変数を使い、1つのエントリとして `0` を保持する可変配列を使うことができます：

```ts
var x : Nat       = 0 ;
let y : [var Nat] = [var 0] ;
```

このエンコーディングに必要な読み取りと書き込みの構文は、可変配列の構文を再利用するため、`var` による変数よりも可読性が低くなります。そのため、変数 `x` の読み取りと書き込みは、変数 `y` のものよりも読みやすくなります。

この実際的な理由と他の理由から、`var` による変数は言語設計の重要な部分です。

## 不変配列

[可変配列](#mutable-arrays)について議論する前に、同じ投影構文を持ちますが、割り当て後に更新が許可されない不変配列を紹介します。

### 不変配列の定義

```ts
let a : [Nat] = [1, 2, 3] ;
```

上記の配列 `a` は3つの自然数を保持し、型は `[Nat]` です。一般に、不変配列の型は `[_]` であり、配列の要素の型を囲む角括弧を使用し、すべての要素は共通の型を持つ必要があります。

### 配列インデックスからの読み取り

配列から読み取るには、通常の角括弧構文 `[` と `]` を使ってアクセスしたいインデックスを指定します：

```ts no-repl
let x : Nat = a[2] + a[0] ;
```

Motoko のすべての配列アクセスは安全です。範囲外のアクセスは不安全にメモリをアクセスすることはなく、代わりに[アサーション](../getting-started/basic-concepts#traps)失敗としてプログラムがトラップします。

## [`Array`](../base/Array.md) モジュール

Motoko 標準ライブラリは不変および可変配列に対する基本操作を提供します。以下のようにインポートできます：

```ts no-repl
import Array "mo:base/Array";
```

配列の使用方法についての詳細は、[配列](../base/Array.md)ライブラリの説明を参照してください。

### 内容が異なる不変配列の割り当て

プログラムによって割り当てられる各新しい配列は異なる数の要素を含みます。変更ができない場合、これらの要素の家族を一度に割り当ての引数として指定する必要があります。

この必要を満たすために、Motoko 言語は高階配列割り当て関数 `Array.tabulate` を提供しており、ユーザーが提供する生成関数 `gen` に基づいて各要素を割り当てる新しい配列を割り当てます。

```ts no-repl
func tabulate<T>(size : Nat,  gen : Nat -> T) : [T]
```

関数 `gen` は、矢印型 `Nat → T` の関数値として配列を指定します。ここで、`T` は最終的な配列要素の型です。

関数 `gen` は、配列の初期化中に配列として機能します。配列要素のインデックスを受け取り、そのインデックスに配置されるべき要素を型 `T` で生成します。割り当てられた出力配列は、この仕様に基づいて自動的に埋められます。

例えば、最初にいくつかの初期定数で構成される `array1` を割り当て、その後純粋で関数的な方法でいくつかのインデックスを変更して、`array2` という新しい配列を作成することができます：

```ts no-repl
let array1 : [Nat] = [1, 2, 3, 4, 6, 7, 8] ;

let array2 : [Nat] = Array.tabulate<Nat>(7, func(i:Nat) : Nat {
    if ( i == 2 or i == 5 ) { array1[i] * i } // 3番目と6番目のエントリを変更
    else { array1[i] } // 他のエントリには変更なし
  }) ;
```

`array1` を `array2` に関数的に変更しましたが、両方の配列も両方の変数も不変であることに注意してください。

## 可変配列

Motoko の各可変配列はプライベートな可変アクター状態を導入します。

Motoko の型システムは、遠隔のアクターがその可変状態を共有しないように強制しているため、Motoko の型システムは可変配列と不変配列の間に明確な区別を設けており、これが型の健全性、サブタイプ、非同期通信の言語抽象に影響します。

ローカルでは、可変配列は不変配列を期待する場所では使用できません。なぜなら、Motoko の配列に関する[サブタイプ](../reference/language-manual#subtyping)定義は、型の健全性の目的でそのようなケースを正しく区別するからです。また、アクター間の通信に関して、不変配列は安全に送信および共有できますが、可変配列はメッセージで共有されたり送信されたりすることはありません。不変配列とは異なり、可変配列には共有できない型があります。

### 定数の可変配列を割り当てる

可変配列を割り当てるためには、可変配列構文 `[var _]` を使用して、式と型の両方に `var` キーワードを使用します：

```ts
let a : [var Nat] = [var 1, 2, 3] ;
```

上記の配列 `a` は3つの自然数を保持し、型は `[var Nat]` です。

### 動的サイズの可変配列を割り当てる

定数サイズでない可変配列を割り当てるためには、`Array.init` 基本ライブラリ関数を使用して初期値を提供します：

```ts no-repl
func init<T>(size : Nat,  x : T) : [var T]
```

例えば：

```ts no-repl
var size : Nat = 42 ;
let x : [var Nat] = Array.init<Nat>(size, 3);
```

変数 `size` はここでは定数である必要はありません。配列は `size` のエントリ数を持ち、各エントリは初期値 `3` を保持します。

### 可変更新

可変配列（型 `[var _]` の各配列）は、個々の要素に対して代入による可変更新を許可します。この場合、インデックス `2` の要素は `3` から `42` に更新されます：

```ts
let a : [var Nat] = [var 1, 2, 3];
a[2] := 42;
a
```

### サブタイプは可変を不変として使用することを許可しない

Motoko のサブタイプは、可変配列の型 `[var Nat]` を不変のもの（型 `[Nat]`）として使用することを許可しません。

これには2つの理由があります。まず、すべての可変状態と同様に、可変配列には健全なサブタイプのための異なるルールが必要です。特に、可変配列には柔軟性の少ないサブタイプ定義が必要です。第二に、Motoko は[非同期通信](actors-async.md)で可変配列を使用することを禁止しており、可変状態は決して共有されることはありません。
