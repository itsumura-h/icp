---
sidebar_position: 2
---

# 基本的な概念と用語

Motokoは、**アクター**を使用した分散プログラミングのために設計されています。ICP上でMotokoを使ってプログラミングを行う場合、各アクターはCandidインターフェースを持つICPカニスタースマートコントラクトを表します。Motoko内では、アクターという用語は、ICPにデプロイするためにどんな言語で作成されたカニスターでも指すために使われます。Motokoの役割は、これらのアクターがデプロイされた後に、プログラム的に簡単に作成して利用できるようにすることです。

Motokoでカニスターを書く前に、Motoko特有のいくつかの基本的な概念と用語に慣れておくべきです。

## 値

### 原始値

Motokoは、次の原始型と値をサポートしています：

-   [`Bool`](../base/Bool.md)：ブール値（`true` と `false`）。

-   [`Int`](../base/Int.md)：整数（…​, `-2`, `-1`, `0`, `1`, `2`, …​）- 制限ありおよび制限なしのバリエーション。

-   [`Nat`](../base/Nat.md)：自然数（`0`, `1`, `2`, …​）- 制限ありおよび制限なしのバリエーション。

- `Char`：Unicodeテキスト文字（`'a'`, `'B'`, `'☃'`）。

-   [`Text`](../base/Text.md)：Unicode文字列のテキスト値。

デフォルトでは、**整数**および**自然数**は**制限なし**であり、オーバーフローは発生しません。その代わり、任意の有限の数に対応できるように成長する表現を使用します。

実際的な理由から、Motokoは**制限あり**型も提供しており、整数と自然数についてはデフォルトのバージョンとは異なるものです。各制限付きバリエーションは固定ビット幅（`8`、`16`、`32`、`64`のいずれか）を持ち、表現できる値の範囲を決定し、オーバーフローの可能性があります。制限を超えるとランタイムでエラーが発生し、プログラムは[トラップ](#traps-due-to-faults)します。

Motokoには、明確に定義された状況を除いて、オーバーフローがチェックされないことはありません。明示的に**ラップ**操作を行う場合には、通常の演算子に`%`という記号を付けて表します。言語は、これらの異なる数値表現間の変換を行うための原始的なビルトイン関数を提供します。

### 非原始値

Motokoはユーザー定義型を許可しており、次の非原始値の形式と関連する型をサポートしています：

-   [タプル](../reference/language-manual#tuples)、単位値（"空のタプル"）を含む。

-   [配列](../reference/language-manual#arrays)、**不変**および**可変**のバリエーション。

-   [オブジェクト](../reference/language-manual#objects)、名前付きの順序なしフィールドとメソッド。

-   [バリアント](../reference/language-manual#variant-types)、名前付きのコンストラクタとオプションのペイロード値。

-   [関数値](../reference/language-manual#functions)、[共有可能な関数](../writing-motoko/sharing.md)を含む。

-   [非同期値](../reference/language-manual#async)、別名**プロミス**または**未来**。

-   [エラー値](../reference/language-manual#error-type)、例外やシステム障害のペイロードを持つ。

原始値および非原始値の正確な言語定義については、[言語リファレンス](../reference/language-manual)を参照してください。

## 値の表示

`print`関数は、基礎ライブラリの[`Debug`](../base/Debug.md)から提供され、`Text`型のテキスト文字列を入力として受け取り、`()`というユニット型の単位値を出力します。

ユニット値は情報を持たないため、ユニット型の値はすべて同一であり、`print`関数は実際には興味深い結果を生成しません。代わりに、`print`関数は人間が読める形式でテキスト文字列を出力端末に表示する効果があります。出力を表示したり、状態を変更したりする副作用のある関数は**不純関数**と呼ばれます。一方、さらに副作用を伴わず、値を返すだけの関数は**純粋関数**と呼ばれます。

Motokoのほとんどの値は、人間が読めるテキスト文字列に変換することができ、デバッグ目的で手動でその変換を記述する必要はありません。`debug_show`というプリミティブは、大きなクラスの値を`Text`型の値に変換することを許可します。

## Motokoプログラムの構文

各Motokoプログラムは、**宣言**と**式**で構成され、これらの構文クラスは異なりますが、[関連しています](../reference/language-manual)。

宣言は、**不変変数**、**可変状態**、**アクター**、**オブジェクト**、**クラス**およびその他の型を導入します。宣言は相互再帰的にすることもできますが、再帰しない場合には、値を等しい値で置き換えるという代入の意味を持ちます。

式は、これらの概念を使った計算を記述します。

ICPにデプロイする有効なプログラムを作成するには、プログラムは`actor`というキーワードで導入されたアクター式で構成されなければなりません。

最初の例として、次のコードスニペットでは、変数`x`と`y`の2つの宣言があり、その後に1つのプログラムを形成する式があります：

``` motoko
let x = 1;
let y = x + 1;
x * y + x;
```

このプログラムの型は[`Nat`](../base/Nat.md)（自然数）であり、実行すると[`Nat`](../base/Nat.md)型の値`3`が評価されます。

このプログラムは、次の3つの宣言からなる宣言リストです：

1.  不変変数`x`、宣言`let x = 1;`によって。

2.  不変変数`y`、宣言`let y = x + 1;`によって。

3.  最後の式の値を保持する名前のない暗黙の変数`x * y + x`。

式`x * y + x`は、必要に応じて各式が宣言として考えられることを示しています。つまり、言語はその式の結果値で名前のない変数を暗黙的に宣言します。

式が最後の宣言として現れる場合、この式は任意の型を持つことができます。ここでは、式`x * y + x`は[`Nat`](../base/Nat.md)型です。

最初でない宣言リスト内に現れる式は、ユニット型`()`を持たなければなりません。

ユニット型の制限は、`ignore`キーワードを明示的に使用することで、使用されていない結果値を無視することで回避できます。

## レキシカルスコープ

宣言リスト自体は式ではないため、その最終値で別の変数を宣言することはできません。

**ブロック式**は、宣言リストを一致する波括弧で囲むことによって形成されます。ブロックは、`if`、`loop`、`case`などの制御フロー式のサブ式としてのみ許可されます。ブロック式は値を生成し、かつ括弧で囲むことで、より大きな複合式内に現れることができます。

:::note

データが欠けていたり不完全であったりする場合の処理のために便利な形のブロックがあります。これらは[オプションブロック](../writing-motoko/pattern-matching.md#option-blocks-for-streamlined-processing-of-optional-data)として説明されています。

:::

その他の場所では、`do { … }`を使用してブロック式を表現し、オブジェクトリテラルと区別します。たとえば、`do {}`は型`()`の空のブロックであり、`{}`は型`{}`の空のレコードです。このブロック形式は、宣言リストの自立性とその変数名の選択を保持します。つまり、変数のスコープは入れ子にすることができますが、入れ子にしても干渉しません。この考え方は、言語理論家が**レキシカルスコープ**と呼ぶものです。

数学的な明確さの他に、レキシカルスコープの主な実用的な利点は、セキュリティと、構成的に安全なシステムを構築するために使用されることです。具体的には、Motokoは非常に強力な構成特性を提供します。たとえば、信頼できないプログラム内に自分のプログラムを入れ子にしても、変数を再定義して異なる意味にすることはできません。

## 型の健全性

型チェックが通ったMotokoの各式は、**型安全**であると見なされます。Motoko式の**型**は、プログラムが実行されるときの挙動について、言語から開発者への約束として機能します。

まず、すべての型安全なプログラムは未定義の動作なしで評価されます。意味のあるプログラムの空間は正確に決まっています。型システムはプログラムがその範囲内にとどまり、型安全なプログラムが正確な意味を持つことを保証します。

さらに、型はプログラムの結果に関する正確な予測を行います。もし制御を返す場合、プログラムは元のプログラムと一致する**結果値**を生成します。

いずれの場合でも、プログラムの静的および動的な見方は型システムによってリンクされ、整合します。この整合性が静的型システムの中心原理であり、Motokoはこれをその設計の中核的な要素として提供します。

同じ型システムは、非同期の相互作用がプログラムの静的および動的な見方の間で一致し、結果的に生成されるメッセージがランタイムで不一致になることがないように強制します。この整合性は、通常の型付き言語で期待される呼び出し元/呼び出し先の引数型および返り値型の整合性に似ています。

## 型アノテーションと変数

変数は、静的な名前と静的な型を動的な値に関連付けますが、この動的な値は実行時にのみ存在します。

この意味で、Motokoの型はプログラムのソースコード内で信頼された、コンパイラ検証済みのドキュメンテーションを提供します。

次の非常に短いプログラムを考えてみましょう：

``` motoko
let x : Nat = 1
```

この例では、コンパイラは式`1`が[`Nat`](../base/Nat.md)型であり、`x`も同じ型であると推論します。

この場合、型アノテーションを省略してもプログラムの意味は変わりません：

``` motoko
let x = 1
```

オペレータのオーバーロードに関する一部の特殊な状況を除いて、型アノテーションは通常、プログラムの実行時の意味に影響を与えることはありません。もし省略され、コンパイラがプログラムを受け入れた場合、プログラムは元々と同じ意味と動作を持ちます。

しかし、型アノテーションはコンパイラが他の仮定を推論し、プログラム全体をチェックするために必要な場合もあります。型アノテーションが追加され、コンパイラがプログラムを受け入れた場合、その追加されたアノテーションが既存のものと一致していることを確認できます。

## 型エラーとメッセージ

Motokoは静的型付けされたプログラミング言語です。つまり、コンパイラは明らかに無意味なコードを含むプログラムを拒否します。

たとえば、2つの数を加算することは許可されていますが、数値をテキスト値に加算することはMotokoコンパイラには意味がなく、エラーとしてフラグされます。このエラーは、コードが実行またはデプロイされる前に修正する必要があります。

Motokoがコードをコンパイルして実行する前にその正当性を検証するために適用するルールは、その型システムと呼ばれます。Motokoの型システムは、関数に対して誤った引数の数や型を渡すなど、静的なエラーを検出し拒否します。

型システムは、安全性のための機能であり、ランタイムでエラーを検出して報告しなければならない多くのエラーを防ぎます。

## Motokoベースライブラリ

さまざまな実用的な言語設計上の理由から、Motokoの設計は組み込み型と操作を最小限に抑えることを目指しています。

その代わりに、可能な限り、Motokoベースライブラリが言語を完全に感じさせる型や操作を提供します。しかし、このベースライブラリはまだ開発中であり、不完全です。

[Motokoベースライブラリ](../base/index.md)は、変更が大きくないと予測される例で使われるコア機能に焦点を当てたモジュールの選択をリストアップしています。ベースライブラリのAPIは、Motokoが成熟するにつれて進化し、サイズと数が増加する可能性があります。

ベースライブラリからインポートするには、`import`キーワードを使用します。ローカルモジュール名を指定して、この例では`D`（**D**ebug）とし、インポート宣言でそのモジュールを見つけられるURLを指定します：

``` motoko file=../examples/print.mo
```

この場合、Motokoコードは`mo:`プレフィックスを付けてインポートし、`base/`パスの後にモジュールのファイル名`Debug.mo`（拡張子は省略）を指定します。

## トラップ

ゼロ除算、範囲外の配列インデックス、パターンマッチ失敗などのエラーは、型システムによって防止されない設計になっており、代わりに**トラップ**という動的な障害を引き起こします。

トラップが発生すると、実行の意味が不定になるため、コードの実行はトラップで中断されます。

:::note

アクターメッセージ内で発生したトラップはより微妙です：アクター全体が中断されるわけではなく、その特定のメッセージが進行しないだけで、未コミットの状態変更がロールバックされます。アクター上の他のメッセージは実行を続けます。これには微妙なセキュリティ上の影響があるため、関連する[セキュリティ推奨事項](https://internetcomputer.org/docs/current/developer-docs/security/security-best-practices/inter-canister-calls#recommendation)を参照することをお勧めします。

:::

時々、ユーザー定義のメッセージで無条件にトラップを強制することが役立つことがあります。

[`Debug`](../base/Debug.md)ライブラリは、これを実行するために`trap(t)`関数を提供しており、任意のコンテキストで使用できます：

``` motoko
import Debug "mo:base/Debug";

Debug.trap("oops!");
```

**アサーション**は、あるブールテストが成立しないとき

に条件付きでトラップを発生させますが、それ以外の場合は実行を続けます：

``` motoko no-repl
let n = 65535;
assert n % 2 == 0; // nが偶数でないときにトラップ
```

アサーションは成功することがあり、その場合実行が続行されるため、型`()`が期待されるコンテキストでのみ使用できます。
