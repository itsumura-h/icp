---
sidebar_position: 1
---

# Motokoを紹介します：Web3の未来を形作る言語

<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />

Motokoは、特にICPカニスタースマートコントラクトを作成するために使用される現代的な汎用プログラミング言語です。主にICPカニスター開発を目的としていますが、その設計は将来的に他のターゲットへのコンパイルもサポートできるほど一般的です。

Motokoは、JavaScriptや他のモダンプログラミング言語（Rust、Swift、TypeScript、C#、Javaなど）でオブジェクト指向や関数型プログラミングの基本的な概念に馴染みがあるプログラマーが扱いやすいように設計されています。

```motoko
// シンプルなMotokoスマートコントラクト。

actor Main {
  public query func hello() : async Text {
    "Hello, world!"
  };
};

await Main.hello();
```


Motokoの特徴：

-   ICPで実行されるアプリケーションをプログラムするための高水準言語。

-   プログラマーが学びやすい、馴染みのある構文を使用したシンプルな設計。

-   効率的なメッセージ処理に最適化された**アクター型**プログラミングモデル。

-   データベースや二次記憶装置なしで、シンプルで安全、効率的なデータストレージを実現する**直交的永続性**。

-   自律的なアプリケーション用のWebAssemblyコードをテストし、コンパイルするためのインタープリターとコンパイラー。

# なぜMotokoなのか？

ICPはさまざまな言語で書かれたプログラムをサポートしています。唯一の要件は、プログラムがWebAssemblyコードにコンパイルできることです。WebAssemblyは、仮想マシン向けの低水準のコンピュータ命令フォーマットです。WebAssemblyコードは、アプリケーションがWebなど多くのプラットフォームで展開できるように設計されているため、ICPで実行することを目的としたアプリケーションの展開に適しています。しかし、WebAssemblyにコンパイルできる高水準言語の多くは、安全性が低いか、セキュアなアプリケーションを提供したい開発者には複雑です。

DFINITYは、正確性を保ちながら複雑さを避けるために、独自のMotokoプログラミング言語を設計しました。Motokoは、新人でも経験豊富なプログラマーでも学びやすい、他のプログラミング言語に対するシンプルで表現力豊かな代替手段を提供します。

## モチベーションと目標

Motokoは、ICPスマートコントラクトにとってシンプルで有用な言語を目指し、アクターモデルを組み込んだ馴染みのある構文を使用しています。MotokoはICPの機能とシームレスに統合され、WebAssemblyの現在と未来の機能を最大限に活用します。

Motokoは、カニスタースマートコントラクトを実装する唯一の言語ではありません。Rust、TypeScript、Python、そして近日中にSolidityのカニスター開発キットも存在します。ICPの目標は、どんな言語でもカニスターソースコードをWebAssemblyにコンパイルできるようにすることです。

しかし、Motokoはその特化した設計により、ICPでのコーディングに最も簡単で安全な言語であるべきです。

## 主な設計ポイント

Motokoは、他にも多くの開発者生産性向上機能を提供します。設計のインスピレーションは、Java、JavaScript、C#、Swift、Pony、ML、Haskellなどの言語から得ています。

Motokoの構文はJavaScriptプログラマーには馴染みやすいですが、JavaScriptの奇妙な部分はありません。

Motokoは、非同期処理の制御を簡単に行える便利なサポートを提供する、並行処理指向の言語です。
そのコアは、命令型とオブジェクト指向の機能を持つ呼び値の非純粋関数型言語です。

Motokoは強い型付けを行い、オプション型、レコード、バリアント、ジェネリクス、サブタイプを提供します。型システムは構造的で、異なる名前の型でも定義が同じであれば交換可能です。サブタイプにより、値はその正確な型で使うことも、より一般的なスーパタイプで使うこともできます。

- Motokoは安全性重視です。
- メモリ管理はガーベジコレクタによって自動化されています。
- 暗黙のnull値は避けられています。nullはオプション型を使用して明示的に処理しなければなりません。
- 型システムはunsafeキャストで回避することはできません。
- 算術演算は、オーバーフローしない無制限の整数を使用するか、制限された整数を使用する場合は、オーバーフローでエラーを発生させる検査付き算術を使用します。
- 関連のない型間の型変換はすべて明示的です。
- 型を別の型に暗黙的に昇格させることは、サブタイプによってゼロコストでのみ実現できます。
- Motokoの簡潔でコンパイラでチェックされたパターンマッチングのサポートは、良いコーディングスタイルと監査可能なコードを促進します。
- エラーを引き起こしやすいオブジェクト指向の継承はサポートされていません。

Motokoのカニスターはコンパイルされ、インタープリタではなく、パフォーマンスに優れた小さなバイナリを生成します。

### ネイティブカニスタースマートコントラクトサポート

Motokoは、Motokoアクターとして表現されるカニスタースマートコントラクトをネイティブにサポートします。アクターは、自分の状態を完全にカプセル化し、他のアクターとは非同期メッセージを通じてのみ通信する自律的なオブジェクトです。

### 直接スタイルで順次コードを書く

ICPでは、カニスターは他のカニスターと非同期メッセージを送信することで通信できます。

非同期プログラミングは難しいですが、Motokoは非同期コードを非常にシンプルで順次的なスタイルで記述できるようにします。非同期メッセージは、未来を返す関数呼び出しであり、`await`構文を使用して未来が完了するまで実行を停止することができます。

### モダンな型システム

Motokoは、JavaScriptや他の人気のある言語に馴染みのある直感的な設計を採用し、構造型、ジェネリクス、バリアント型、静的にチェックされたパターンマッチングなどのモダンな機能を提供します。

### 自動生成されるIDLファイル

Motokoアクターは、常にそのクライアントに対して型付きインターフェースを提供します。このインターフェースは、引数や未来の結果型を持つ名前付き関数のスイートとして表現されます。

MotokoコンパイラとIC SDKは、このインターフェースをCandidという言語中立の形式で出力できます。これにより、Candidをサポートする他のカニスター、ブラウザ内コード、スマートフォンアプリがアクターのサービスを使用できるようになります。MotokoコンパイラはCandidファイルを消費・生成できるため、Motokoは他のプログラミング言語で実装されたカニスターとシームレスに連携できます。

### 直交的永続性

ICPは、カニスターが実行される際にそのメモリやその他の状態情報を永続化します。したがって、Motokoアクターの状態、つまりそのメモリ内のデータ構造は無期限に存続します。アクターの状態は明示的に外部ストレージに復元したり保存したりする必要はありません。

### アップグレード

Motokoは、カニスターのコードをアップグレードする際にそのデータを保持するための言語機能を提供します。

例えば、Motokoでは`stable`という変数を宣言することができます。`stable`変数の値は、カニスターのアップグレードを跨いで自動的に保持されます。

アップグレード後、新しいインターフェースは以前のインターフェースと互換性があり、既存のクライアントがカニスターを参照し続けても動作しますが、新しいクライアントはそのアップグレードされた機能を活用できるようになります。さらに複雑な変更に関しては、Motokoはユーザー定義の[明示的マイグレーション](../canister-maintenance/compatibility.md#explicit-migration)によって安全に対応できます。

## 始めるには

Motokoを始めるには、[開発環境の設定](dev-env.md)を行い、シンプルな[Hello, world!](quickstart.md)プログラムを作成しましょう。
