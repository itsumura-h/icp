https://medium.com/dfinity/web-authentication-and-identity-on-the-internet-computer-a9bd5754c547

# インターネットコンピュータにおけるウェブ認証とアイデンティティ

> インターネットコンピュータは、ユーザー名とパスワードを、より高度で安全な暗号認証方法に置き換えます。
> 著者：Björn Tackmann、チームリード、リサーチ | DFINITY

インターネットコンピュータの文脈でアイデンティティと認証が何を意味するかを理解するには、まず、インターネットコンピュータがどのようにアイデンティティと認証を扱っているかを理解する必要があります。インターネットコンピュータは、ウェブの速度で動作し、その容量を無制限に拡大できる世界初のブロックチェーンネットワークです。これを理解するために、まず現在のウェブでのアイデンティティと認証の使用方法を考える必要があります。

ウェブサイトにログインするとき、ユーザー名は通常、あなたのメールアドレスか、アルファベットと数字の文字列で、サーバー上の関連データとあなたのアイデンティティを結びつける一意の識別子として機能します。パスワードは認証手段です。理論的には、あなたのみがそのパスワードを知っているべきなので、サーバーはあなたのパスワードをあなたと通信している証拠として解釈します。しかし、パスワードは実際にはリモート認証のための良いメカニズムではないことが分かりました。

ウェブサイトにパスワードを入力すると、コンピュータはそのパスワードをサーバーに送信し、パスワードデータベースと照合します。残念ながら、ハッカーはこれらのパスワードデータベースにアクセスできる可能性があります。最も悪質な場合、パスワードがプレーンテキストでサーバーに保存されており、これは推奨されないセキュリティ慣行です。しかし、たとえパスワードが暗号化されていたとしても、それを復号することは、ハッカーがアクセスするために投資する計算リソースと金銭的リソースに依存する問題です。

インターネットコンピュータは、複数のデータセンターにデータと計算を複製することによって、個々のコンピュータープロバイダーの悪意のある行動に対するセキュリティを提供するように設計されています。データの複製はデータの整合性を保護しますが、情報漏洩を防ぐわけではありません。インターネットコンピュータでパスワードを使用することは、従来のウェブと同じセキュリティ問題に直面することになります。したがって、インターネットコンピュータでは、パスワードを適切な暗号認証に置き換えています。

[こちらのリンクで動画を見る](https://www.youtube.com/watch?v=9eUTcCP_ELM)

インターネットコンピュータで認証に使用する主な暗号化メカニズムは、デジタル署名方式です。デジタル署名はかなり標準的な概念です。1970年代後半に発明され、1990年代中頃から広く使用されています。

デジタル署名は通常、3つのアルゴリズムから成り立っています：

- **鍵生成**：これは、パスワードを選ぶことに似たものと考えられます。鍵生成は、1) 秘密に保持する必要がある秘密鍵と、2) 秘密鍵から派生し、公開可能な公開鍵のペアを作成します。
- **署名**：メッセージと秘密鍵を取り、署名を生成します。ユーザー認証にデジタル署名を使用する場合、このアルゴリズムはユーザー側で実行され、秘密鍵が保持されます。
- **検証**：メッセージ、署名、公開鍵を取り、署名がメッセージと公開鍵に一致することを確認します。ここで重要なのは、パスワードをチェックする場合のように秘密のパスワードをサーバーに保存する必要がないことです。署名の検証は公開情報だけで行うことができます。サーバーは、各ユーザーの公開鍵をリストとして保存しており、公開鍵や署名は秘密にする必要はありません。

インターネットコンピュータ上のアプリケーションは、メッセージのやり取りを通じて相互作用するカニスター・スマートコントラクトに基づいて実装されます。少し詳しく言うと、この相互作用モデルはリモートプロシージャコール（RPC）のようなリクエストベースです。カニスターAがカニスターBを呼び出すと、カニスターAはターゲットカニスター（カニスターB）、呼び出す関数の名前、引数を指定します。指定された関数がカニスターBで評価されると、そのカニスターはその関数がカニスターAによって呼び出されたことを認識します。評価が完了すると、カニスターAはその関数の戻り値をレスポンスとして取得します。同じリモートプロシージャコールモデルがユーザーとカニスターの相互作用にも適用されます。ユーザーがカニスターを呼び出すと、ユーザーはターゲットカニスターにリクエストを送信します。このリクエストには、関数と引数も指定されており、ユーザーは戻り値をレスポンスとして受け取ります。リクエストのバリエーション中に、カニスターはその呼び出し元のユーザーのアイデンティティも知ることができます。

![](https://miro.medium.com/v2/resize:fit:720/format:webp/1*XiLv6n_fzyMeWRekneC1lA.png)

上図は、ユーザーから送信されたリクエストの概略図です。中央の薄い灰色の部分は、リクエストのコアを示しています：ターゲットカニスターID、関数名、引数、および呼び出し元のアイデンティティまたはプリンシパルです。ダークグレーの部分は、認証情報、署名、公開鍵を含む封筒を示しています。左側に示されているように、呼び出し元のプリンシパルは公開鍵からハッシュ化して導出されます。この技術は、ビットコインやイーサリアムアドレスなど、ブロックチェーン空間で広く使用されています。右側では、デジタル署名方式のメッセージとしてリクエストの内容がどのように署名を通じて公開鍵にバインドされるかを示しています。インターネットコンピュータがこのようなリクエストを受け取ると、指定された公開鍵のもとで署名が有効かどうか、また公開鍵と呼び出し元のプリンシパルとの関係を確認します。

メッセージが本当に指定された呼び出し元から送信されたことを確認するために、カニスターはこれらの技術的詳細に関与する必要はありません。すべてがチェックされると、インターネットコンピュータは指定された関数をカニスター上で評価します。もし、チェックの1つでも失敗した場合、リクエストは単純に破棄されます。

![](https://miro.medium.com/v2/resize:fit:720/format:webp/1*SjKH1gn76fPZSSR7yX-cRw.png)

私たちが使用するプリンシパルのフォーマットについていくつかの詳細を説明します。まず、公開鍵をDER形式で取得し、それをSHA-224でハッシュ化して28バイトの文字列を作成します。その後、プリンシパルが公開鍵から導出されたものであることを区別するための1バイトを追加します。これらの29バイトは、ユーザーのプリンシパルの内部バイナリ表現です。プリンシパルをテキスト形式に変換する際は、最初にCRC-32エラーチェックコードを追加し、次にその文字列をBase32でエンコードします。最後に、ダッシュで区切られた5文字ごとにグループ化します。このフォーマットは、適切なエラーチェックを行いつつ、インターネットプロトコル（例えばDNS）との互換性を持たせるために選ばれました。

![](https://miro.medium.com/v2/resize:fit:720/format:webp/1*Su4ey3EES8gZp9iS8G-7UQ.png)

ここまで見てきた方式は、構造的にやや柔軟性に欠けます。それはユーザーのプリンシパルを単一の暗号鍵に結びつけているためです。この制限により、ユーザーが異なるデバイスからカニスターとやり取りするのが難しくなります。なぜなら、同じ暗号鍵をそれらのデバイス間で共有する必要があるからです。このため、セキュリティ上の観点からもこれは推奨されません。その代わりに、異なる暗号鍵間での委任を使用します。上記の図では、黄色の鍵からオレンジの鍵への委任が示されています。この委任は、委任された鍵（オレンジ）と、期限や委任範囲の制限などの追加パラメータ、そして委任元の鍵（黄色）の署名で構成されています。

オレンジの鍵でリクエストに署名する場合、ユーザーは今、黄色の鍵から派生したアイデンティティを使用するためにその委任を含めることができます。委任が特に強力なのは、それらが合成可能であることです。例えば、オレンジの鍵は、委任を紫の鍵に拡張できます。もしこれが公開鍵インフラストラクチャ（PKI）やX.509からのものに似ていると感じたのであれば、それは偶然ではありません。私たちは単に、より軽量なデータ構造を使用しているだけです。

委任の具体的なアプリケーションの1つは、ウェブ認証に関連しています。ウェブ認証は、World Wide Web Consortium（W3C）の最近の標準であり、主にウェブアプリケーションの二要素認証をターゲットにしています。標準の目的は、前述の通り、パスワードに重大なセキュリティ上の欠陥があることです。

それらはサイバー犯罪者のターゲットになりがちで、フィッシングメールやユーザーのデバイスにインストールされたマルウェア、あるいはサービスがハッキングされることによって危険にさらされます。

[こちらでウェブ認証の詳細を見る](https://medium.com/dfinity/internet-identity-the-end-of-usernames-and-passwords-ff45e4861bf7)

二要素認証（2FA）とは、パスワードに加えて、ウェブアプリケーションにログインする際に、通常、ユーザーが所有するセキュアなデバイスを使用することを意味します。実際には、それはセキュアなUSBキーや、ユーザーの端末デバイスに内蔵されたセキュアチップであり、バイオメトリクスを通じて有効化されます。このセキュアチップは暗号鍵を保存しており、暗号鍵はセキュアチップから外に出ることがないため、たとえユーザーのコンピュータや電話がマルウェアに感染しても安全が保たれます。

ウェブ認証が第二要素として使用される場合、プロトコルフローは以下のようになります：ユーザーがユーザー名とパスワードを提供してログインプロセスを開始すると、ウェブサーバーはランダムなチャレンジを生成し、それをユーザーのブラウザに送信します。ブラウザはそのチャレンジをセキュアデバイスに送信し、セキュアデバイスはユーザーの操作を要求した後にそのチャレンジに署名します。署名されたチャレンジはサーバーに戻され、サーバーはそのチャレンジに対する署名をユーザーの登録された公開鍵に基づいて検証します。これにより、ウェブアプリケーションへのログインには、パスワードだけでなくセキュアデバイスも必要になります。

ウェブ認証は、デジタル署名を使用した認証のオープン標準であり、広範囲なデバイスで既にサポートされています。それをインターネットコンピュータに適応させるにあたり、いくつかのハードルを乗り越えなければなりませんでした。ウェブ認証は従来のウェブのセッション指向クライアントサーバーモデルを前提としています。ユーザーはログイン時に一度認証し、その後同じセッション内でメッセージを送信します。これに対してインターネットコンピュータは、各リクエストが個別に認証されるモデルを実装しています。特に、ブラウザとインターネットコンピュータ間には状態を保持するセッションがないため、サーバーがセキュアデバイスに署名を求めるチャレンジを生成できません。従来のウェブ認証フローでは、サーバーが送信したチャレンジに対してセキュアデバイスがデジタル署名を行いますが、インターネットコンピュータではこれを直接再現する必要がありました。

そのため、インターネットコンピュータではリクエスト自体をチャレンジとして使用し、それをセキュアデバイスに署名させることで、一般的なリクエスト認証のスキームに類似した方法で認証を実装しています。さらに、ウェブ認証はすべての署名にユーザーの操作を必要とするため、インターネットコンピュータの典型的なフロントエンドでは、単一のページロードが複数のリクエストに対応することがあります。ユーザーに毎回署名を明示的に確認させたくないため、上記の委任メカニズムを利用しています。ウェブ認証を使用してカニスターとやり取りする際、まず短期間のセッションキーを生成し、そのセッションキーに対して委任を署名することで、単一のユーザー操作で複数のリクエストをトリガーできます。

![](https://miro.medium.com/v2/resize:fit:720/format:webp/1*790puXyExFtt5FRJcX1wHg.png)

ウェブ認証は暗号鍵を安全に保存するために優れていますが、それらの鍵はデバイスだけでなく、特定のカニスターにも結びつけられています。この理由は、ブラウザのセキュリティモデルにあり、これは同じウェブブラウザで実行される異なるアプリケーションがオリジンごとにアクセスできる状態を厳格に分離するものです。ウェブでは、オリジンはおおよそ1つのウェブサイトに対応します。インターネットコンピュータでは、各オリジンが1つのカニスターに対応します。この厳格な状態分離はセキュリティにとって非常に重要ですが、キーのバックアップや、複数のデバイスから同じカニスターにシームレスにアクセスするためのサポートなど、いくつかの機能を面倒にしてしまいます。なぜなら、これらの操作はすべて各カニスターごとに個別に行う必要があるからです。この問題を解決するために、インターネットアイデンティティサービスを使用しています。これは、ウェブでよく見られる「GoogleまたはFacebookでサインイン」の機能に似たアイデンティティプロバイダーです。

ユーザーが特定のカニスターのフロントエンドを最初にロードすると、そのフロントエンドは「ICでサインイン」ボタンを表示できます。ユーザーがそのボタンをクリックすると、ブラウザはインターネットアイデンティティサービスをポップアップで開き、ユーザーがキーやアイデンティティを管理するための特定のアプリケーションが表示されます。そこで、ユーザーはカニスターのフロントエンドがユーザーのアイデンティティを使用することを許可するかどうかを決定できます。ユーザーが承認すると、ブラウザはカニスターのフロントエンドにリダイレクトされ、ユーザーのアイデンティティでカニスターにアクセスできます。このメカニズムは再びセッションキーと委任メカニズムを利用しています。カニスターのフロントエンドはセッションキーのペアを生成し、その公開鍵をインターネットアイデンティティに転送します。ユーザーが承認すると、インターネットアイデンティティが委任を生成し、それをカニスターのフロントエンドに返します。ビッグテックプロバイダーを介したサインインと比較して、追加の利点は、アイデンティティプロバイダー内での完全な認証フローがユーザー側で行われるため、ユーザーのプライベートなアクションの露出が大幅に減少し、追跡が大幅に減少することです。（インターネットアイデンティティサービスFAQ）

[インターネットアイデンティティサービスのFAQを確認](https://sdk.dfinity.org/docs/ic-identity-guide/auth-how-to.html?source=post_page-----a9bd5754c547---------------------------------------)

ユーザートラッキングについて言えば、インターネットアイデンティティは、ユーザーがログインするすべてのカニスターのフロントエンドに対して異なるアイデンティティを生成します。これはセキュリティとプライバシーにとって素晴らしいことです。もしそうでなければ、インターネットアイデンティティは、すべてのフロントエンドがユーザーの単一のプリンシパルでログインできるようにしてしまいます。このユーザーが関連のないサービスとやり取りすると、例えば、掲示板とショッピングサイトが、これらのサイトでのユーザーの行動を裏で相関させることができます。さらに悪いことに、掲示板のフロントエンドが悪意を持ってショッピングサイトのカニスターを呼び出し、ユーザーの名前で注文を行うこともできます。したがって、インターネットアイデンティティサービスは、ユーザーがログインするすべてのフロントエンドに対して異なるアイデンティティを生成します。このようにして、ユーザーが異なるサービスで行うアクションは簡単には追跡されません。フロントエンドは、ユーザーのアイデンティティでインターネットコンピュータ上のどのカニスターにも呼び出しを行うことができますが、呼び出しを行うフロントエンドに関連付けられたアイデンティティだけが使用されます。

上記のメカニズムとインターネットアイデンティティで使用される仕組みは、最近リリースされたインターネットコンピュータインターフェース仕様書に詳細に記載されています。そして、私たちは開発者コミュニティがこれを基にどんなものを作り出すのかを楽しみにしています。
