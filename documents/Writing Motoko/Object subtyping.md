---
sidebar_position: 18
---

# オブジェクトのサブタイプ

**オブジェクトのサブタイプ** : Motoko では、オブジェクトにはサブタイプの関係を持つ型があります。フィールドが多い型は一般的でなく、フィールドが少ない型のサブタイプとなります。以下の一般的な型とサブタイプを考えてみましょう：

- 最も一般的な型：

```ts no-repl
{ bump : () -> Nat }
```

- 中程度の一般性：

```ts no-repl
{
  inc  : () -> () ;
  read : () -> Nat ;
  bump : () -> Nat ;
}
```

- 最も特定的な型：

```ts no-repl
{
  inc  : () -> () ;
  read : () -> Nat ;
  bump : () -> Nat ;
  write : Nat -> () ;
}
```

もし関数が最初の型（`{ bump: () → Nat }`）のオブジェクトを受け取ることを期待している場合、上記の型のいずれも適応されます。なぜなら、それぞれが最も一般的な型と等しいか、サブタイプだからです。

しかし、もし関数が最も特定的な型（最後の型）を受け取ることを期待している場合、他の2つは*適応されません*。なぜなら、それぞれが必要な `write` 操作を欠いており、この関数は正当にその操作にアクセスすることを期待しているからです。

## 例

Motoko におけるオブジェクトのサブタイプの役割と使用方法を説明するために、公開操作が少ないより一般的な型で簡単なカウンターを実装する例を考えてみましょう：

```ts
object bumpCounter {
  var c = 0;
  public func bump() : Nat {
    c += 1;
    c
  };
};
```

オブジェクト `bumpCounter` には以下のオブジェクト型があり、ちょうど1つの操作 `bump` を公開しています：

```ts no-repl
{
  bump : () -> Nat ;
}
```

この型は最も一般的な操作を公開しており、それは特定の動作のみを許可します。例えば、このカウンターは増加しかできず、減少させたり任意の値に設定したりすることはできません。

システムの他の部分では、より多くの操作を持つ、あまり一般的でないバージョンを実装して使用することができます：

```ts no-repl
fullCounter : {
  inc   : () -> () ;
  read  : () -> Nat ;
  bump  : () -> Nat ;
  write : Nat -> () ;
}
```

`fullCounter` というカウンターを考えてみましょう。これは上記のいずれの型よりも少し特定的な型です。`inc`、`read`、`bump` に加えて、`write` も含まれており、呼び出し元が現在のカウント値を任意の値（例えば `0` に戻すなど）に変更することを許可します。

## 構造的サブタイプ

Motoko におけるオブジェクトのサブタイプは、名義サブタイプではなく構造的サブタイプを使用します。

名義型では、2つの型が等しいかどうかは、プロジェクト間および時間を通じて一貫した、グローバルに一意の型名を選択することに依存します。

Motoko では、2つの型の等価性はその名前ではなく、構造に基づいています。構造型のため、クラス型に名前を付けることは便利な省略形を提供します。

型付けの目的では、重要なのは対応するオブジェクト型の構造だけです。異なる名前を持つ2つのクラスがあっても、それらが同等の定義を持っていれば型互換のオブジェクトが生成されます。

クラス宣言でオプションの型注釈が提供された場合、適合性がチェックされます。オブジェクト型は注釈のサブタイプでなければなりません。注釈はクラスの型に影響を与えることはなく、それがオブジェクト型の適切なスーパータイプであっても変わりません。

Motoko のサブタイピング関係は、オブジェクト型に限定されず、すべての型に拡張されます。

ほとんどのケースは標準的で、*構造的* サブタイピングに関する従来のプログラミング言語理論に従います。

Motoko における新しいプログラマにとって注目すべき他のケースには、配列、オプション、バリアント、数値型間の相互関係があります。
