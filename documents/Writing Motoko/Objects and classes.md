---
sidebar_position: 13
---

# オブジェクトとクラス

Motokoにおけるオブジェクトは、名前付きフィールドのコレクションであり、値を保持します。これらの値は、プレーンデータまたは関数の値である可能性があります。また、各フィールドは可変または不変にすることができます。

データフィールドのみを含むシンプルなオブジェクトは、データベースのレコードのようなものです。
フィールドが不変で、共有型を持っている場合、そのオブジェクト自体は共有可能であり、共有関数から送受信できます。

関数値を含むフィールドがある場合、Motokoのオブジェクトは、オブジェクト指向プログラミング（OOP）でよく見られるメソッドを持つ従来のオブジェクトを表現できます。
OOPの観点では、オブジェクトはそのメソッドの振る舞いによって定義される抽象概念です。メソッドは通常、オブジェクトの隠れた（すなわち、カプセル化された）状態を変更または観察するために使用されます。
Motokoプログラムは、状態をオブジェクトとして抽象型でカプセル化できることから利益を得ています。[可変状態](mutable-state.md)は、`var`で宣言された変数の形で可変状態を導入します。このような宣言をその本体内で非公開に使用することで、オブジェクトは状態をカプセル化し、状態をアクセスおよび更新する公開メソッドを宣言できます。

設計上、可変フィールドやメソッドを持つオブジェクトはリモートアクターに送信できません。もしそれが許可されると、受信者はローカルオブジェクトのリモート参照を受け取ることになり、アクターモデルの隔離が破られてローカル状態がリモートで更新されることになります。あるいは、受信者はローカルオブジェクトのコピーを受け取ることになります。この場合、コピーに対する変更は元のオブジェクトに反映されず、混乱を招くことになります。

この必要な制限を補うために、`actor`オブジェクトは共有可能ですが、常にリモートで実行されます。これらは共有可能なMotokoデータとのみ通信します。ローカルオブジェクトは制限の少ない方法で自分自身と相互作用し、他のオブジェクトを含むMotokoデータを他のメソッドに渡すことができます。ほとんどの他の方法では、ローカルオブジェクトとクラスは、アクターオブジェクトとクラスの非共有対応物です。

## 例

以下の例は、Motokoプログラムの一般的な進化パスを示しています。各オブジェクトは、ローカルオブジェクトをアクターオブジェクトにリファクタリングすることでサービスに変換する可能性を持っています。

次の`counter`オブジェクトの宣言を考えてみましょう：

```ts
object counter {
  var count = 0;
  public func inc() { count += 1 };
  public func read() : Nat { count };
  public func bump() : Nat {
    inc();
    read()
  };
};
```

この宣言では、`counter`という名前の単一のオブジェクトインスタンスを紹介しています。開発者は`inc`、`read`、`bump`の3つの公開関数を`public`キーワードを使ってオブジェクト本体内で宣言します。オブジェクトの本体は、ブロック式のように宣言のリストで構成されています。

これらの3つの関数に加えて、このオブジェクトには1つの非公開の可変変数`count`があり、現在のカウントを保持し、初期値は0です。

## オブジェクト型

この`counter`オブジェクトには、以下のオブジェクト型があります。これはフィールドと型のペアのリストとして記述され、波括弧`{`と`}`で囲まれています：

```ts no-repl
{
  inc  : () -> () ;
  read : () -> Nat ;
  bump : () -> Nat ;
}
```

各フィールド型は、識別子、コロン`:`、およびフィールドの内容の型で構成されています。ここでは、各フィールドは関数であり、したがって矢印型の形式（`_ -> _`）を持っています。

`object`の宣言では、変数`count`は`public`でも`private`でも明示的に宣言されていません。

デフォルトでは、オブジェクトブロック内のすべての宣言は`private`です。そのため、`count`の型はオブジェクトの型には現れません。その名前と存在は外部からアクセスできません。

この実装の詳細を公開しないことによって、オブジェクトはフィールドが少なく、より一般的な型を持ち、その結果、同じインターフェースを持つ異なる実装のオブジェクトと交換可能になります。

この点を示すために、上記の`counter`宣言のバリエーションである`byteCounter`を考えてみましょう：

```ts
import Nat8 "mo:base/Nat8";
object byteCounter {
  var count : Nat8 = 0;
  public func inc() { count += 1 };
  public func read() : Nat { Nat8.toNat(count) };
  public func bump() : Nat { inc(); read() };
};
```

このオブジェクトは前のものと同じ型を持っており、したがって型チェックの観点から見ると、このオブジェクトは以前のものと交換可能です：

```ts no-repl
{
  inc  : () -> () ;
  read : () -> Nat ;
  bump : () -> Nat ;
}
```

このバージョンでは、カウンタフィールドの実装が異なります。通常の自然数[`Nat`](../base/Nat.md)の代わりに、8ビットの自然数型[`Nat8`](../base/Nat8.md)が使用されており、このサイズは常に8ビットです。

そのため、このオブジェクトでは`inc`操作がオーバーフローで失敗する可能性がありますが、前のオブジェクトではプログラムのメモリを満たすことになります。

カウンタのいずれの実装にもいくつかの複雑さはありますが、共通の型を持っています。

共通の型は、オブジェクトの実装の違いを抽象化し、アプリケーションの他の部分からその実装の詳細を隠します。

オブジェクト型はまた、[サブタイプ](object-subtyping.md)を持つことができ、これにより、より具体的な型のオブジェクトをより一般的な型のオブジェクトとして渡すことができます。例えば、フィールドが少ないオブジェクトとして渡すことができます。

## オブジェクトとアクタークラス

**オブジェクトクラス**：関連するオブジェクトのファミリーで、カスタマイズ可能な初期状態でタスクを実行します。Motokoは、`class`定義という構文構造を提供し、同じ型と実装のオブジェクトを簡単に構築できるようにします。

**アクタークラス**：非同期動作を使用してサービスを公開するオブジェクトクラス。対応するMotokoの構造は[アクタークラス](actor-classes.md)であり、類似していますが、異なる設計です。

## オブジェクトクラス

Motokoでは、オブジェクトは状態をカプセル化し、オブジェクト`class`は共通の名前を持つ2つのエンティティをまとめたものです。

このカウンタ用の`class`の例を考えてみましょう。初期値はゼロです：

```ts no-repl
class Counter() {
  var c = 0;
  public func inc() : Nat {
    c += 1;
    return c;
  }
};
```

この定義の価値は、新しいカウンタを構築し、各カウンタが最初に独自の状態（初期値はゼロ）から開始できることです：

```ts no-repl
let c1 = Counter();
let c2 = Counter();
```

それぞれが独立しています：

```ts no-repl
let x = c1.inc();
let y = c2.inc();
(x, y)
```

同じ結果を、オブジェクトを返す関数を書くことでも実現できます：

```ts
func Counter() : { inc : () -> Nat } =
  object {
    var c = 0;
    public func inc() : Nat { c += 1; c }
  };
```

このコンストラクタ関数の戻り値の型はオブジェクト型です：

```ts no-repl
{ inc : () -> Nat }
```

この型を使って、さらなる型宣言に`Counter`の名前を使うことができます：

```ts no-repl
type Counter = { inc : () -> Nat };
```

上記の`class`キーワードの構文は、2つの定義の省略形です：オブジェクトを構築するファクトリ関数`Counter`と、これらのオブジェクトの型`Counter`です。クラスはこの便利さ以外の新しい機能は提供しません。

### クラスコンストラクタ

オブジェクトクラスは、0個以上のデータ引数と0個以上の型引数を取るコンストラクタ関数を定義します。

上記の`Counter`の例では、引数はどちらもありません。次の例では、データ引数`arg1`と`arg2`を取り、これらの引数の型はそれぞれ`Type1`と`Type2`です。

```ts no-repl
class MyClass(arg1: Type1

, arg2: Type2) {
  // クラスの本体
};
```

例えば、`Nat`型の引数と`Bool`型の引数を取る`Counter`クラスを書くことができます：

```ts no-repl
import Nat "mo:base/Nat";

persistent actor {

  class Counter(init : Nat, flag : Bool) {
    var c = init;
    var f = flag;
    public func inc() : Nat {
      if f {
        c += 1;
      };
      return c;
    };
  };

}
```

データ引数がある場合、それらはクラスのコンストラクタ関数のみをパラメータ化します。

#### データ引数

カウンタを非ゼロ値で初期化したい場合、その値をデータ引数として`class`コンストラクタに渡すことができます：

```ts
class Counter(init : Nat) {
  var c = init;
  public func inc() : Nat { c += 1; c };
};
```

このパラメータはすべてのメソッドで利用できます。例えば、`Counter`を初期値にリセットする`reset`メソッドを追加できます：

```ts
class Counter(init : Nat) {
  var c = init;
  public func inc() : Nat { c += 1; c };
  public func reset() { c := init };
};
```

#### 型引数

カウンタが実際に数えるデータを持つようにしたい場合、例えば特殊な`Buffer`を使う場合です。

クラスが任意の型のデータを使用または含む場合、型引数を持ちます。これは、関数と同様に型パラメータとして機能します。

この型パラメータの範囲は、`class`のデータパラメータ全体をカバーします。したがって、クラスのメソッドは再度宣言しなくてもこれらの型パラメータを使用できます。

```ts
import Buffer "mo:base/Buffer";

class Counter<X>(init : Buffer.Buffer<X>) {
  var buffer = init.clone();
  public func add(x : X) : Nat {
    buffer.add(x);
    buffer.size()
  };

  public func reset() {
    buffer := init.clone()
  };
};
```

#### 型注釈

クラスコンストラクタは、戻り値の型の型注釈を持つこともできます。渡される型注釈は、クラスの本体であるオブジェクト定義と互換性があることをMotokoはチェックします。このチェックは、コンストラクタによって生成された各オブジェクトが提供された仕様に従っていることを確認します。

例えば、`Counter`をバッファとして再定義し、それをより一般的な型`Accum<X>`で注釈して、カウンタを追加できますがリセットはできません。この注釈により、オブジェクトが`Accum<X>`型と互換性があることが保証されます。

```ts
import Buffer "mo:base/Buffer";

type Accum<X> = { add : X -> Nat };

class Counter<X>(init : Buffer.Buffer<X>) : Accum<X> {
  var buffer = init.clone();
  public func add(x : X) : Nat { buffer.add(x); buffer.size() };
  public func reset() { buffer := init.clone() };
};
```

#### 完全な構文

クラスは`class`キーワードで定義され、次の要素を含みます：

- 定義するコンストラクタおよび型の名前（例：`Counter`）。
- 任意の型引数（例：省略、`<X>`、または`<X, Y>`）。
- 引数リスト（例：`()`、`(init : Nat)`など）。
- オプションの戻り値の型注釈（例：省略、または`Accum<X>`）。
- クラスの本体は、引数付きのオブジェクト定義です。

クラスの本体で`public`とマークされた構成要素は、生成されたオブジェクトの型に貢献し、オプションの注釈と比較されます。

自然数[`Nat`](../base/Nat.md)のビットを歩くタスクを考えてみましょう。この例では、次のように定義できます：

```ts
class Bits(n : Nat) {
  var state = n;
  public func next() : ?Bool {
    if (state == 0) { return null };
    let prev = state;
    state /= 2;
    ?(state * 2 != prev)
  }
}
```

このクラス定義は、構造型同義語とファクトリ関数の同時定義と同等です。

```ts no-repl
type Bits = { next : () -> ?Bool };
func Bits(n : Nat) : Bits = object {
  // クラスの本体
};
```

## オブジェクトの組み合わせと拡張

Motokoでは、単純なレコードから複雑なオブジェクトブロックを使って単一のオブジェクトを構築したり、既存のオブジェクトから新しいオブジェクトを構築して、新しいフィールドを追加したり、既存のフィールドを置き換えたりするための構文が提供されています。

ベースとなるレコードとオブジェクトは`and`キーワードで区切られ、続けて`with`を使って追加（または上書き）されるフィールドをセミコロンで区切って指定します。
ベースとフィールドは波括弧`{}`で囲まれ、レコードとして形成されます。
もしベースに重複するフィールド（型に従ったもの）があれば、曖昧さを解消するためにフィールドの上書きを提供しなければなりません。
元のベースは決して変更されません。代わりに、フィールドはコピーされ、新しいオブジェクトが作成されるため、これを関数型のオブジェクトの組み合わせおよび拡張と呼びます。

以下にいくつかのシンプルな例を示します：

1. `and`によるオブジェクトの組み合わせ：
   `and`キーワードは、2つ以上のオブジェクトを組み合わせます。

```ts
let person = { name = "Alice"; };
let employee = { id = 123; department = "Engineering" };

let employedPerson = { person and employee };
// employedPersonは今、name, id, departmentを持っています
```

2. `with`によるオブジェクトの拡張：
   `with`キーワードを使って新しいフィールドを追加したり、既存のフィールドを上書きしたりできます。

```ts
let person = { name = "Alice" };

let agedPerson = { person with age = 30 };

// agedPersonは今、nameとageを持っています
```

3. `and`と`with`を組み合わせる：
   より複雑なオブジェクト操作のために、`and`と`with`を一緒に使うことができます。

```ts
let person = { name = "Alice" };
let employee = { id = 123; department = "Engineering" };

let employedPersonWithAge = { person and employee with age = 30 };
// employedPersonWithAgeは今、name, id, department, ageを持っています
```

覚えておくべき重要なポイント：
- `and`を使用する際、ベースの間でフィールド名が衝突した場合、`with`フィールドを使って衝突を解決する必要があります。
- `with`句はフィールドラベルの曖昧さを解消したり、新しいフィールドを定義したり、既存のフィールドを上書きしたり、新しい`var`フィールドを追加したり、既存の`var`フィールドを再定義したりしてエイリアスの生成を防ぎます。
- ベースオブジェクトからの`var`フィールドを明示的に上書きして、エイリアスの生成を防ぐ必要があります。

この構文は、Motokoでモジュール化され、再利用可能なコードを作成する便利な方法を提供し、開発者がシンプルなコンポーネントから複雑なオブジェクトを構築したり、既存のオブジェクトに新しい機能を追加したりすることを可能にします。

詳細については、[言語マニュアル](../reference/language-manual#object-combinationextension)をご覧ください。

<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />
